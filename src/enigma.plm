/* Enigma cipher in PL/M (Intel microprocessor language) */
ENIGMA$MODULE:
DO;
    DECLARE ROTOR$FWD$1 (26) BYTE DATA (
        4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9);
    DECLARE ROTOR$FWD$2 (26) BYTE DATA (
        0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4);
    DECLARE ROTOR$FWD$3 (26) BYTE DATA (
        1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14);
    DECLARE ROTOR$BWD$1 (26) BYTE DATA (
        20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9);
    DECLARE ROTOR$BWD$2 (26) BYTE DATA (
        0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18);
    DECLARE ROTOR$BWD$3 (26) BYTE DATA (
        19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12);
    DECLARE REFLECTOR (26) BYTE DATA (
        24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19);
    DECLARE NOTCHES (3) BYTE DATA (16, 4, 21);
    DECLARE POS (3) BYTE;

    MOD26: PROCEDURE (N) BYTE;
        DECLARE N BYTE;
        DECLARE M BYTE;
        M = N MOD 26;
        RETURN M;
    END MOD26;

    ROTOR$PASS: PROCEDURE (WIRING$PTR, C, P) BYTE;
        DECLARE WIRING$PTR ADDRESS;
        DECLARE C BYTE, P BYTE;
        DECLARE WIRING BASED WIRING$PTR (26) BYTE;
        RETURN MOD26(WIRING(MOD26(C + P)) - P + 26);
    END ROTOR$PASS;

    ENCRYPT$CHAR: PROCEDURE (CH) BYTE;
        DECLARE CH BYTE;
        DECLARE C BYTE;
        C = CH;
        C = ROTOR$PASS(.ROTOR$FWD$3, C, POS(2));
        C = ROTOR$PASS(.ROTOR$FWD$2, C, POS(1));
        C = ROTOR$PASS(.ROTOR$FWD$1, C, POS(0));
        C = REFLECTOR(C);
        C = ROTOR$PASS(.ROTOR$BWD$1, C, POS(0));
        C = ROTOR$PASS(.ROTOR$BWD$2, C, POS(1));
        C = ROTOR$PASS(.ROTOR$BWD$3, C, POS(2));
        RETURN C;
    END ENCRYPT$CHAR;

    /* Initialize */
    POS(0) = 0; POS(1) = 0; POS(2) = 0;
END ENIGMA$MODULE;
