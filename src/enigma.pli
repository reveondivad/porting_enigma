/* Enigma Cipher - PL/I */
/* IBM mainframe programming language */

ENIGMA: PROCEDURE OPTIONS(MAIN);
    DECLARE (FWD_I(0:25), FWD_II(0:25), FWD_III(0:25)) FIXED BINARY(31);
    DECLARE (BWD_I(0:25), BWD_II(0:25), BWD_III(0:25)) FIXED BINARY(31);
    DECLARE NOTCH(0:2) FIXED BINARY(31);
    DECLARE REFLECTOR(0:25) FIXED BINARY(31);
    DECLARE PLUGBOARD(0:25) FIXED BINARY(31);

    FWD_I  = {4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9};
    FWD_II = {0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4};
    FWD_III= {1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14};

    BWD_I  = {20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9};
    BWD_II = {0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18};
    BWD_III= {19,0,6,1,15,2,18,3,16,4,20,9,21,13,25,7,24,8,23,5,22,11,17,12,14,10};

    NOTCH = {16, 4, 21};
    REFLECTOR = {24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19};

    DECLARE (R0, R1, R2, O0, O1, O2) FIXED BINARY(31);

    MOD26: PROCEDURE(X) RETURNS(FIXED BINARY(31));
        DECLARE X FIXED BINARY(31);
        DECLARE M FIXED BINARY(31);
        M = MOD(X, 26);
        IF M < 0 THEN M = M + 26;
        RETURN(M);
    END MOD26;

    GET_FWD: PROCEDURE(ROTOR, IDX) RETURNS(FIXED BINARY(31));
        DECLARE (ROTOR, IDX) FIXED BINARY(31);
        IF ROTOR = 0 THEN RETURN(FWD_I(IDX));
        IF ROTOR = 1 THEN RETURN(FWD_II(IDX));
        RETURN(FWD_III(IDX));
    END GET_FWD;

    GET_BWD: PROCEDURE(ROTOR, IDX) RETURNS(FIXED BINARY(31));
        DECLARE (ROTOR, IDX) FIXED BINARY(31);
        IF ROTOR = 0 THEN RETURN(BWD_I(IDX));
        IF ROTOR = 1 THEN RETURN(BWD_II(IDX));
        RETURN(BWD_III(IDX));
    END GET_BWD;

    PASS_FWD: PROCEDURE(ROTOR, OFFSET, CH) RETURNS(FIXED BINARY(31));
        DECLARE (ROTOR, OFFSET, CH) FIXED BINARY(31);
        DECLARE (INP, OUTP) FIXED BINARY(31);
        INP = MOD26(CH + OFFSET);
        OUTP = GET_FWD(ROTOR, INP);
        RETURN(MOD26(OUTP - OFFSET));
    END PASS_FWD;

    PASS_BWD: PROCEDURE(ROTOR, OFFSET, CH) RETURNS(FIXED BINARY(31));
        DECLARE (ROTOR, OFFSET, CH) FIXED BINARY(31);
        DECLARE (INP, OUTP) FIXED BINARY(31);
        INP = MOD26(CH + OFFSET);
        OUTP = GET_BWD(ROTOR, INP);
        RETURN(MOD26(OUTP - OFFSET));
    END PASS_BWD;

    MAKE_PB: PROCEDURE(PAIRS, NPAIRS);
        DECLARE PAIRS(*) FIXED BINARY(31);
        DECLARE NPAIRS FIXED BINARY(31);
        DECLARE I FIXED BINARY(31);
        DO I = 0 TO 25; PLUGBOARD(I) = I; END;
        DO I = 1 TO NPAIRS * 2 BY 2;
            PLUGBOARD(PAIRS(I)) = PAIRS(I+1);
            PLUGBOARD(PAIRS(I+1)) = PAIRS(I);
        END;
    END MAKE_PB;

    ENCRYPT: PROCEDURE(PR0, PR1, PR2, PK0, PK1, PK2, MSG, MSGLEN, RESULT);
        DECLARE (PR0, PR1, PR2, PK0, PK1, PK2, MSGLEN) FIXED BINARY(31);
        DECLARE MSG CHARACTER(100) VARYING;
        DECLARE RESULT CHARACTER(100) VARYING;
        DECLARE (C, I, CH) FIXED BINARY(31);
        DECLARE MID BIT(1);
        DECLARE ATN2 BIT(1);

        O0 = PK0; O1 = PK1; O2 = PK2;
        R0 = PR0; R1 = PR1; R2 = PR2;
        RESULT = '';

        DO I = 1 TO MSGLEN;
            CH = RANK(SUBSTR(MSG, I, 1)) - RANK('A');
            /* Step rotors */
            MID = (O1 = NOTCH(R1));
            ATN2 = (O2 = NOTCH(R2));
            O2 = MOD26(O2 + 1);
            IF ATN2 | MID THEN O1 = MOD26(O1 + 1);
            IF MID THEN O0 = MOD26(O0 + 1);
            /* Encrypt */
            C = PLUGBOARD(CH);
            C = PASS_FWD(R2, O2, C);
            C = PASS_FWD(R1, O1, C);
            C = PASS_FWD(R0, O0, C);
            C = REFLECTOR(C);
            C = PASS_BWD(R0, O0, C);
            C = PASS_BWD(R1, O1, C);
            C = PASS_BWD(R2, O2, C);
            C = PLUGBOARD(C);
            RESULT = RESULT || COLLATE(C + RANK('A'));
        END;
    END ENCRYPT;

    DECLARE (RESULT, EXPECTED) CHARACTER(100) VARYING;
    DECLARE PAIRS(6) FIXED BINARY(31);
    DECLARE STATUS CHARACTER(4);

    PUT SKIP LIST('Enigma Cipher - PL/I');

    /* Test 1 */
    CALL MAKE_PB(PAIRS, 0);
    CALL ENCRYPT(0,1,2, 0,0,0, 'AAAAA', 5, RESULT);
    IF RESULT = 'BDZGO' THEN STATUS = 'PASS'; ELSE STATUS = 'FAIL';
    PUT SKIP LIST(STATUS || ' Test 1: ' || RESULT || ' (expected BDZGO)');

    /* Test 2 */
    CALL MAKE_PB(PAIRS, 0);
    CALL ENCRYPT(0,1,2, 0,0,0, 'HELLOWORLD', 10, RESULT);
    IF RESULT = 'ILBDAAMTAZ' THEN STATUS = 'PASS'; ELSE STATUS = 'FAIL';
    PUT SKIP LIST(STATUS || ' Test 2: ' || RESULT || ' (expected ILBDAAMTAZ)');

    /* Test 3 */
    CALL MAKE_PB(PAIRS, 0);
    CALL ENCRYPT(0,1,2, 0,0,0, 'ATTACKATDAWN', 12, RESULT);
    IF RESULT = 'BZHGNOCRRTCM' THEN STATUS = 'PASS'; ELSE STATUS = 'FAIL';
    PUT SKIP LIST(STATUS || ' Test 3: ' || RESULT || ' (expected BZHGNOCRRTCM)');

    /* Test 4 */
    CALL MAKE_PB(PAIRS, 0);
    CALL ENCRYPT(0,1,2, 12,2,10, 'HELLOWORLD', 10, RESULT);
    IF RESULT = 'DLTBBQVPQV' THEN STATUS = 'PASS'; ELSE STATUS = 'FAIL';
    PUT SKIP LIST(STATUS || ' Test 4: ' || RESULT || ' (expected DLTBBQVPQV)');

    /* Test 5 */
    CALL MAKE_PB(PAIRS, 0);
    CALL ENCRYPT(2,0,1, 0,0,0, 'HELLOWORLD', 10, RESULT);
    IF RESULT = 'KZHDFQYHXT' THEN STATUS = 'PASS'; ELSE STATUS = 'FAIL';
    PUT SKIP LIST(STATUS || ' Test 5: ' || RESULT || ' (expected KZHDFQYHXT)');

    /* Test 6 */
    PAIRS(1) = 0; PAIRS(2) = 1; PAIRS(3) = 2; PAIRS(4) = 3; PAIRS(5) = 4; PAIRS(6) = 5;
    CALL MAKE_PB(PAIRS, 3);
    CALL ENCRYPT(0,1,2, 0,0,0, 'HELLOWORLD', 10, RESULT);
    IF RESULT = 'IKACBBMTBF' THEN STATUS = 'PASS'; ELSE STATUS = 'FAIL';
    PUT SKIP LIST(STATUS || ' Test 6: ' || RESULT || ' (expected IKACBBMTBF)');

END ENIGMA;
