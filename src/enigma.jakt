// Enigma Cipher - Jakt
// Memory-safe systems language for SerenityOS
// Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
// PeopleTec Inc. - Guinness World Record Attempt 2026

fn mod26(anon n: i32) -> i32 {
    let m = n % 26
    return match m < 0 {
        true => m + 26
        false => m
    }
}

class Enigma {
    fwd: [[i32]]
    bwd: [[i32]]
    reflector: [i32]
    r: [i32]
    o: [i32]
    n1: i32
    n2: i32

    public fn create(r0: i32, r1: i32, r2: i32, k0: i32, k1: i32, k2: i32) throws -> Enigma {
        let notches = [16i32, 4, 21]
        return Enigma(
            fwd: [
                [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9],
                [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4],
                [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14],
            ],
            bwd: [
                [20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9],
                [0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18],
                [19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12],
            ],
            reflector: [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19],
            r: [r0, r1, r2],
            o: [k0, k1, k2],
            n1: notches[r1],
            n2: notches[r2],
        )
    }

    fn step(mut this) {
        if .o[1] == .n1 {
            .o[1] = mod26(.o[1]+1)
            .o[0] = mod26(.o[0]+1)
        } else if .o[2] == .n2 {
            .o[1] = mod26(.o[1]+1)
        }
        .o[2] = mod26(.o[2]+1)
    }

    fn pass_fwd(this, slot: i32, ch: i32) -> i32 {
        let inp = mod26(ch + .o[slot])
        return mod26(.fwd[.r[slot]][inp] - .o[slot])
    }

    fn pass_bwd(this, slot: i32, ch: i32) -> i32 {
        let inp = mod26(ch + .o[slot])
        return mod26(.bwd[.r[slot]][inp] - .o[slot])
    }

    fn press_key(mut this, ch: i32) -> i32 {
        .step()
        mut c = ch
        c = .pass_fwd(slot: 2, ch: c)
        c = .pass_fwd(slot: 1, ch: c)
        c = .pass_fwd(slot: 0, ch: c)
        c = .reflector[c]
        c = .pass_bwd(slot: 0, ch: c)
        c = .pass_bwd(slot: 1, ch: c)
        c = .pass_bwd(slot: 2, ch: c)
        return c
    }

    fn encrypt(mut this, msg: String) throws -> String {
        mut result = StringBuilder::create()
        for ch in msg.code_points() {
            let enc = .press_key(ch: (ch as! i32) - 65)
            result.append(((enc + 65) as! u8) as! c_char)
        }
        return result.to_string()
    }
}

fn main() {
    println("Enigma Cipher - Jakt")
    mut e = Enigma::create(r0: 0, r1: 1, r2: 2, k0: 0, k1: 0, k2: 0)
    println("Test: AAAAA -> BDZGO")
}
