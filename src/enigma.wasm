;; Enigma Cipher - WebAssembly Text Format (WAT)
;; Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
;; PeopleTec Inc. - Guinness World Record Attempt 2026

(module
  ;; Memory: rotor tables stored at offset 0
  (memory (export "memory") 1)

  ;; Store rotor data in memory at initialization
  ;; Offset 0-25: fwd_I, 26-51: fwd_II, 52-77: fwd_III
  ;; Offset 78-103: bwd_I, 104-129: bwd_II, 130-155: bwd_III
  ;; Offset 156-181: reflector
  ;; Offset 182-184: notches
  ;; Offset 200-202: rotor indices, 203-205: offsets, 206-207: notch vals

  (data (i32.const 0) "\04\0a\0c\05\0b\06\03\10\15\19\0d\13\0e\16\18\07\17\14\12\0f\00\08\01\11\02\09")
  (data (i32.const 26) "\00\09\03\0a\12\08\11\14\17\01\0b\07\16\13\0c\02\10\06\19\0d\0f\18\05\15\0e\04")
  (data (i32.const 52) "\01\03\05\07\09\0b\02\0f\11\13\17\15\19\0d\18\04\08\16\06\00\0a\0c\14\12\10\0e")
  (data (i32.const 78) "\14\16\18\06\00\03\05\0f\15\19\01\04\02\0a\0c\13\07\17\12\0b\11\08\0d\10\0e\09")
  (data (i32.const 104) "\00\09\0f\02\19\16\11\0b\05\01\03\0a\0e\13\18\14\10\06\04\0d\07\17\0c\08\15\12")
  (data (i32.const 130) "\13\00\06\01\0f\02\12\03\10\04\14\05\15\0d\19\07\18\08\17\09\16\0b\11\0a\0e\0c")
  (data (i32.const 156) "\18\11\14\07\10\12\0b\03\0f\17\0d\06\0e\0a\0c\08\04\01\05\19\02\16\15\09\00\13")
  (data (i32.const 182) "\10\04\15")

  ;; mod26
  (func $mod26 (param $n i32) (result i32)
    (local $m i32)
    (local.set $m (i32.rem_s (local.get $n) (i32.const 26)))
    (if (result i32) (i32.lt_s (local.get $m) (i32.const 0))
      (then (i32.add (local.get $m) (i32.const 26)))
      (else (local.get $m))
    )
  )

  ;; Get forward wiring value
  (func $getFwd (param $r i32) (param $i i32) (result i32)
    (i32.load8_u
      (i32.add
        (i32.mul (local.get $r) (i32.const 26))
        (local.get $i)
      )
    )
  )

  ;; Get backward wiring value
  (func $getBwd (param $r i32) (param $i i32) (result i32)
    (i32.load8_u
      (i32.add
        (i32.add (i32.const 78) (i32.mul (local.get $r) (i32.const 26)))
        (local.get $i)
      )
    )
  )

  ;; Forward pass
  (func $passFwd (param $rotor i32) (param $offset i32) (param $ch i32) (result i32)
    (call $mod26
      (i32.sub
        (call $getFwd
          (local.get $rotor)
          (call $mod26 (i32.add (local.get $ch) (local.get $offset)))
        )
        (local.get $offset)
      )
    )
  )

  ;; Backward pass
  (func $passBwd (param $rotor i32) (param $offset i32) (param $ch i32) (result i32)
    (call $mod26
      (i32.sub
        (call $getBwd
          (local.get $rotor)
          (call $mod26 (i32.add (local.get $ch) (local.get $offset)))
        )
        (local.get $offset)
      )
    )
  )

  ;; Initialize: store rotor config at offset 200
  (func $init (export "init")
    (param $r0 i32) (param $r1 i32) (param $r2 i32)
    (param $k0 i32) (param $k1 i32) (param $k2 i32)
    (i32.store8 (i32.const 200) (local.get $r0))
    (i32.store8 (i32.const 201) (local.get $r1))
    (i32.store8 (i32.const 202) (local.get $r2))
    (i32.store8 (i32.const 203) (local.get $k0))
    (i32.store8 (i32.const 204) (local.get $k1))
    (i32.store8 (i32.const 205) (local.get $k2))
    (i32.store8 (i32.const 206) (i32.load8_u (i32.add (i32.const 182) (local.get $r1))))
    (i32.store8 (i32.const 207) (i32.load8_u (i32.add (i32.const 182) (local.get $r2))))
  )

  ;; Step rotors
  (func $step
    (local $o0 i32) (local $o1 i32) (local $o2 i32)
    (local $n1 i32) (local $n2 i32)
    (local.set $o0 (i32.load8_u (i32.const 203)))
    (local.set $o1 (i32.load8_u (i32.const 204)))
    (local.set $o2 (i32.load8_u (i32.const 205)))
    (local.set $n1 (i32.load8_u (i32.const 206)))
    (local.set $n2 (i32.load8_u (i32.const 207)))
    (if (i32.eq (local.get $o1) (local.get $n1))
      (then
        (i32.store8 (i32.const 204) (call $mod26 (i32.add (local.get $o1) (i32.const 1))))
        (i32.store8 (i32.const 203) (call $mod26 (i32.add (local.get $o0) (i32.const 1))))
      )
      (else
        (if (i32.eq (local.get $o2) (local.get $n2))
          (then
            (i32.store8 (i32.const 204) (call $mod26 (i32.add (local.get $o1) (i32.const 1))))
          )
        )
      )
    )
    (i32.store8 (i32.const 205) (call $mod26 (i32.add (i32.load8_u (i32.const 205)) (i32.const 1))))
  )

  ;; Press key: encrypt single character
  (func $pressKey (export "pressKey") (param $ch i32) (result i32)
    (local $c i32)
    (call $step)
    (local.set $c (local.get $ch))
    ;; Forward: R->M->L
    (local.set $c (call $passFwd (i32.load8_u (i32.const 202)) (i32.load8_u (i32.const 205)) (local.get $c)))
    (local.set $c (call $passFwd (i32.load8_u (i32.const 201)) (i32.load8_u (i32.const 204)) (local.get $c)))
    (local.set $c (call $passFwd (i32.load8_u (i32.const 200)) (i32.load8_u (i32.const 203)) (local.get $c)))
    ;; Reflector
    (local.set $c (i32.load8_u (i32.add (i32.const 156) (local.get $c))))
    ;; Backward: L->M->R
    (local.set $c (call $passBwd (i32.load8_u (i32.const 200)) (i32.load8_u (i32.const 203)) (local.get $c)))
    (local.set $c (call $passBwd (i32.load8_u (i32.const 201)) (i32.load8_u (i32.const 204)) (local.get $c)))
    (local.set $c (call $passBwd (i32.load8_u (i32.const 202)) (i32.load8_u (i32.const 205)) (local.get $c)))
    (local.get $c)
  )
)
;; Test: init(0,1,2,0,0,0) then pressKey(0)x5 -> 1,3,25,6,14 (BDZGO)
