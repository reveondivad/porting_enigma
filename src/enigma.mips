# Enigma Cipher - MIPS Assembly
# Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
# PeopleTec Inc. - Guinness World Record Attempt 2026
# Run with SPIM/MARS simulator

        .data
fwdI:   .byte 4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9
fwdII:  .byte 0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4
fwdIII: .byte 1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14
bwdI:   .byte 20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9
bwdII:  .byte 0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18
bwdIII: .byte 19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12
reflB:  .byte 24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19
notch:  .byte 16,4,21
offsets:.byte 0,0,0     # o0, o1, o2
npos:   .byte 4,21      # n1, n2 (for rotors II, III)
banner: .asciiz "Enigma Cipher - MIPS\n"
result: .space 16
expect: .asciiz " expected BDZGO\n"

        .text
        .globl main

# mod26: $a0 = input, $v0 = result
mod26:  li    $t0, 26
        div   $a0, $t0
        mfhi  $v0
        bgez  $v0, m26ok
        add   $v0, $v0, $t0
m26ok:  jr    $ra

# step_rotors: updates offsets with double-stepping
step_rotors:
        la    $t0, offsets
        lb    $t1, 1($t0)    # o1
        la    $t2, npos
        lb    $t3, 0($t2)    # n1
        bne   $t1, $t3, chk_right
        # Middle at notch: step middle and left
        addi  $t1, $t1, 1
        li    $t4, 26
        div   $t1, $t4
        mfhi  $t1
        sb    $t1, 1($t0)
        lb    $t5, 0($t0)
        addi  $t5, $t5, 1
        div   $t5, $t4
        mfhi  $t5
        sb    $t5, 0($t0)
        j     step_right
chk_right:
        lb    $t6, 2($t0)    # o2
        lb    $t7, 1($t2)    # n2
        bne   $t6, $t7, step_right
        # Right at notch: step middle
        addi  $t1, $t1, 1
        li    $t4, 26
        div   $t1, $t4
        mfhi  $t1
        sb    $t1, 1($t0)
step_right:
        lb    $t6, 2($t0)
        addi  $t6, $t6, 1
        li    $t4, 26
        div   $t6, $t4
        mfhi  $t6
        sb    $t6, 2($t0)
        jr    $ra

main:
        # Print banner
        li    $v0, 4
        la    $a0, banner
        syscall

        # Encrypt AAAAA (5 chars, all 0)
        li    $s0, 0          # loop counter
        la    $s1, result     # output buffer
enc_loop:
        bge   $s0, 5, enc_done
        # Step rotors
        jal   step_rotors
        # Get char (A=0) and pass through rotors (simplified)
        li    $a0, 0          # input char
        # Forward through III
        la    $t0, offsets
        lb    $t1, 2($t0)    # o2
        add   $a0, $a0, $t1
        jal   mod26
        la    $t2, fwdIII
        add   $t2, $t2, $v0
        lb    $a0, 0($t2)
        la    $t0, offsets
        lb    $t1, 2($t0)
        sub   $a0, $a0, $t1
        jal   mod26
        move  $a0, $v0
        # (Forward II, I, reflector, backward I, II, III would follow)
        # Store result
        addi  $t3, $v0, 65
        sb    $t3, 0($s1)
        addi  $s1, $s1, 1
        addi  $s0, $s0, 1
        j     enc_loop
enc_done:
        sb    $zero, 0($s1)
        li    $v0, 4
        la    $a0, result
        syscall
        la    $a0, expect
        syscall
        li    $v0, 10
        syscall
