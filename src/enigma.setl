-- Enigma Cipher - SETL
-- Set-theoretic programming language

program enigma;

const
    fwd_I := [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9];
    fwd_II := [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4];
    fwd_III := [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14];
    bwd_I := [20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9];
    bwd_II := [0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18];
    bwd_III := [19,0,6,1,15,2,18,3,16,4,20,9,21,13,25,7,24,8,23,5,22,11,17,12,14,10];
    notches := [16, 4, 21];
    reflector := [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19];

var fwd, bwd;

fwd := [fwd_I, fwd_II, fwd_III];
bwd := [bwd_I, bwd_II, bwd_III];

proc mod26(x);
    return ((x mod 26) + 26) mod 26;
end proc;

proc pass_fwd(rotor, offset, ch);
    var inp, outp;
    inp := mod26(ch + offset);
    outp := fwd(rotor + 1)(inp + 1);
    return mod26(outp - offset);
end proc;

proc pass_bwd(rotor, offset, ch);
    var inp, outp;
    inp := mod26(ch + offset);
    outp := bwd(rotor + 1)(inp + 1);
    return mod26(outp - offset);
end proc;

proc make_plugboard(pairs);
    var pb;
    pb := [i - 1 : i in [1..26]];
    for p in pairs loop
        pb(p(1) + 1) := p(2);
        pb(p(2) + 1) := p(1);
    end loop;
    return pb;
end proc;

proc encrypt(r0, r1, r2, k0, k1, k2, pairs, msg);
    var pb, o0, o1, o2, result, ch, c, mid, atn;
    pb := make_plugboard(pairs);
    o0 := k0; o1 := k1; o2 := k2;
    result := "";
    for i in [1..#msg] loop
        ch := abs(msg(i)) - abs("A");
        mid := o1 = notches(r1 + 1);
        atn := o2 = notches(r2 + 1);
        o2 := mod26(o2 + 1);
        if atn or mid then o1 := mod26(o1 + 1); end if;
        if mid then o0 := mod26(o0 + 1); end if;
        c := pb(ch + 1);
        c := pass_fwd(r2, o2, c);
        c := pass_fwd(r1, o1, c);
        c := pass_fwd(r0, o0, c);
        c := reflector(c + 1);
        c := pass_bwd(r0, o0, c);
        c := pass_bwd(r1, o1, c);
        c := pass_bwd(r2, o2, c);
        c := pb(c + 1);
        result +:= char(c + abs("A"));
    end loop;
    return result;
end proc;

proc run_test(label, expected, actual);
    var status;
    if expected = actual then status := "PASS"; else status := "FAIL"; end if;
    print(status, " ", label, ": ", actual, " (expected ", expected, ")");
end proc;

print("Enigma Cipher - SETL");
run_test("Test 1", "BDZGO", encrypt(0,1,2, 0,0,0, [], "AAAAA"));
run_test("Test 2", "ILBDAAMTAZ", encrypt(0,1,2, 0,0,0, [], "HELLOWORLD"));
run_test("Test 3", "BZHGNOCRRTCM", encrypt(0,1,2, 0,0,0, [], "ATTACKATDAWN"));
run_test("Test 4", "DLTBBQVPQV", encrypt(0,1,2, 12,2,10, [], "HELLOWORLD"));
run_test("Test 5", "KZHDFQYHXT", encrypt(2,0,1, 0,0,0, [], "HELLOWORLD"));
run_test("Test 6", "IKACBBMTBF", encrypt(0,1,2, 0,0,0, [[0,1],[2,3],[4,5]], "HELLOWORLD"));

end program;
