# Enigma Cipher - Monte
# Capability-secure language (successor to E)
# Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
# PeopleTec Inc. - Guinness World Record Attempt 2026

def fwdI :List[Int] := [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9]
def fwdII :List[Int] := [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4]
def fwdIII :List[Int] := [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14]
def bwdI :List[Int] := [20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9]
def bwdII :List[Int] := [0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18]
def bwdIII :List[Int] := [19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12]
def reflector :List[Int] := [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19]
def notches :List[Int] := [16, 4, 21]

def mod26(n :Int) :Int:
    def m := n %% 26
    return if (m < 0) {m + 26} else {m}

def getFwd(r :Int, i :Int) :Int:
    return switch (r):
        match ==0: fwdI[i]
        match ==1: fwdII[i]
        match _: fwdIII[i]

def getBwd(r :Int, i :Int) :Int:
    return switch (r):
        match ==0: bwdI[i]
        match ==1: bwdII[i]
        match _: bwdIII[i]

def passFwd(rotor, offset, ch):
    def inp := mod26(ch + offset)
    return mod26(getFwd(rotor, inp) - offset)

def passBwd(rotor, offset, ch):
    def inp := mod26(ch + offset)
    return mod26(getBwd(rotor, inp) - offset)

def makeEnigma(r0, r1, r2, k0, k1, k2):
    var r := [r0, r1, r2]
    var o := [k0, k1, k2]
    def n1 := notches[r1]
    def n2 := notches[r2]

    return object enigma:
        to step():
            if (o[1] == n1):
                o := o.with(1, mod26(o[1]+1))
                o := o.with(0, mod26(o[0]+1))
            else if (o[2] == n2):
                o := o.with(1, mod26(o[1]+1))
            o := o.with(2, mod26(o[2]+1))

        to pressKey(ch :Int) :Int:
            enigma.step()
            var c := ch
            c := passFwd(r[2],o[2],c)
            c := passFwd(r[1],o[1],c)
            c := passFwd(r[0],o[0],c)
            c := reflector[c]
            c := passBwd(r[0],o[0],c)
            c := passBwd(r[1],o[1],c)
            c := passBwd(r[2],o[2],c)
            return c

        to encrypt(msg :Str) :Str:
            var result := ""
            for ch in (msg):
                def v := enigma.pressKey(ch.asInteger() - 65)
                result += (v + 65).asChar().asString()
            return result

traceln("Enigma Cipher - Monte")
def e := makeEnigma(0,1,2,0,0,0)
traceln(`Test 1: ${e.encrypt("AAAAA")} expected BDZGO`)
