-- Enigma Cipher - Euphoria
-- Simple, fast, safe programming language

include std/sequence.e
include std/text.e

constant FWD = {
    {4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9},
    {0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4},
    {1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14}
}

constant BWD = {
    {20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9},
    {0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18},
    {19,0,6,1,15,2,18,3,16,4,20,9,21,13,25,7,24,8,23,5,22,11,17,12,14,10}
}

constant NOTCH = {16, 4, 21}
constant REFLECTOR = {24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19}

function mod26(integer x)
    integer m = remainder(x, 26)
    if m < 0 then m += 26 end if
    return m
end function

function pass_fwd(integer rotor, integer offset, integer ch)
    integer inp = mod26(ch + offset)
    integer out_val = FWD[rotor + 1][inp + 1]
    return mod26(out_val - offset)
end function

function pass_bwd(integer rotor, integer offset, integer ch)
    integer inp = mod26(ch + offset)
    integer out_val = BWD[rotor + 1][inp + 1]
    return mod26(out_val - offset)
end function

function make_plugboard(sequence pairs)
    sequence pb = {}
    for i = 0 to 25 do
        pb = append(pb, i)
    end for
    for i = 1 to length(pairs) do
        integer a = pairs[i][1]
        integer b = pairs[i][2]
        pb[a + 1] = b
        pb[b + 1] = a
    end for
    return pb
end function

function encrypt(integer r0, integer r1, integer r2,
                 integer k0, integer k1, integer k2,
                 sequence pairs, sequence msg)
    sequence pb = make_plugboard(pairs)
    integer o0 = k0, o1 = k1, o2 = k2
    sequence result = ""
    for i = 1 to length(msg) do
        integer ch = msg[i] - 'A'
        integer mid = (o1 = NOTCH[r1 + 1])
        integer atn = (o2 = NOTCH[r2 + 1])
        o2 = mod26(o2 + 1)
        if atn or mid then o1 = mod26(o1 + 1) end if
        if mid then o0 = mod26(o0 + 1) end if
        integer c = pb[ch + 1]
        c = pass_fwd(r2, o2, c)
        c = pass_fwd(r1, o1, c)
        c = pass_fwd(r0, o0, c)
        c = REFLECTOR[c + 1]
        c = pass_bwd(r0, o0, c)
        c = pass_bwd(r1, o1, c)
        c = pass_bwd(r2, o2, c)
        c = pb[c + 1]
        result &= c + 'A'
    end for
    return result
end function

procedure run_test(sequence label, sequence expected, sequence actual)
    sequence status
    if equal(expected, actual) then status = "PASS"
    else status = "FAIL"
    end if
    printf(1, "%s %s: %s (expected %s)\n", {status, label, actual, expected})
end procedure

puts(1, "Enigma Cipher - Euphoria\n")
run_test("Test 1", "BDZGO", encrypt(0,1,2, 0,0,0, {}, "AAAAA"))
run_test("Test 2", "ILBDAAMTAZ", encrypt(0,1,2, 0,0,0, {}, "HELLOWORLD"))
run_test("Test 3", "BZHGNOCRRTCM", encrypt(0,1,2, 0,0,0, {}, "ATTACKATDAWN"))
run_test("Test 4", "DLTBBQVPQV", encrypt(0,1,2, 12,2,10, {}, "HELLOWORLD"))
run_test("Test 5", "KZHDFQYHXT", encrypt(2,0,1, 0,0,0, {}, "HELLOWORLD"))
run_test("Test 6", "IKACBBMTBF", encrypt(0,1,2, 0,0,0, {{0,1},{2,3},{4,5}}, "HELLOWORLD"))
