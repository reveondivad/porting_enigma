;; Enigma Cipher - Hy (Lisp on Python)
;; Note: .carp2 to avoid collision with .carp
;; Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
;; PeopleTec Inc. - Guinness World Record Attempt 2026
;; Hy is a Lisp dialect that runs on the Python VM

(setv fwd-I  [4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9])
(setv fwd-II [0 9 3 10 18 8 17 20 23 1 11 7 22 19 12 2 16 6 25 13 15 24 5 21 14 4])
(setv fwd-III [1 3 5 7 9 11 2 15 17 19 23 21 25 13 24 4 8 22 6 0 10 12 20 18 16 14])
(setv bwd-I  [20 22 24 6 0 3 5 15 21 25 1 4 2 10 12 19 7 23 18 11 17 8 13 16 14 9])
(setv bwd-II [0 9 15 2 25 22 17 11 5 1 3 10 14 19 24 20 16 6 4 13 7 23 12 8 21 18])
(setv bwd-III [19 0 6 1 15 2 18 3 16 4 20 5 21 13 25 7 24 8 23 9 22 11 17 10 14 12])
(setv reflector [24 17 20 7 16 18 11 3 15 23 13 6 14 10 12 8 4 1 5 25 2 22 21 9 0 19])
(setv notches [16 4 21])

(defn mod26 [n]
  (let [m (% n 26)]
    (if (< m 0) (+ m 26) m)))

(defn get-fwd [r i]
  (cond [(= r 0) (get fwd-I i)]
        [(= r 1) (get fwd-II i)]
        [True (get fwd-III i)]))

(defn get-bwd [r i]
  (cond [(= r 0) (get bwd-I i)]
        [(= r 1) (get bwd-II i)]
        [True (get bwd-III i)]))

(defn pass-fwd [rotor offset ch]
  (let [inp (mod26 (+ ch offset))
        out (get-fwd rotor inp)]
    (mod26 (- out offset))))

(defn pass-bwd [rotor offset ch]
  (let [inp (mod26 (+ ch offset))
        out (get-bwd rotor inp)]
    (mod26 (- out offset))))

(defclass Enigma []
  (defn __init__ [self r0 r1 r2 k0 k1 k2]
    (setv self.r [r0 r1 r2])
    (setv self.o [k0 k1 k2])
    (setv self.n1 (get notches r1))
    (setv self.n2 (get notches r2)))

  (defn step [self]
    (cond [(= (get self.o 1) self.n1)
           (do (assoc self.o 1 (mod26 (+ (get self.o 1) 1)))
               (assoc self.o 0 (mod26 (+ (get self.o 0) 1))))]
          [(= (get self.o 2) self.n2)
           (assoc self.o 1 (mod26 (+ (get self.o 1) 1)))])
    (assoc self.o 2 (mod26 (+ (get self.o 2) 1))))

  (defn press-key [self ch]
    (.step self)
    (let [c ch
          c (pass-fwd (get self.r 2) (get self.o 2) c)
          c (pass-fwd (get self.r 1) (get self.o 1) c)
          c (pass-fwd (get self.r 0) (get self.o 0) c)
          c (get reflector c)
          c (pass-bwd (get self.r 0) (get self.o 0) c)
          c (pass-bwd (get self.r 1) (get self.o 1) c)
          c (pass-bwd (get self.r 2) (get self.o 2) c)]
      c))

  (defn encrypt [self msg]
    (.join "" (lfor ch msg (chr (+ (.press-key self (- (ord ch) 65)) 65))))))

(print "Enigma Cipher - Hy")
(let [e (Enigma 0 1 2 0 0 0)]
  (print f"Test 1: {(.encrypt e \"AAAAA\")} expected BDZGO"))
(let [e (Enigma 0 1 2 0 0 0)]
  (print f"Test 2: {(.encrypt e \"HELLOWORLD\")} expected ILBDAAMTAZ"))
(let [e (Enigma 0 1 2 0 0 0)]
  (print f"Test 3: {(.encrypt e \"ATTACKATDAWN\")} expected BZHGNOCRRTCM"))
(let [e (Enigma 0 1 2 12 2 10)]
  (print f"Test 4: {(.encrypt e \"HELLOWORLD\")} expected DLTBBQVPQV"))
(let [e (Enigma 2 0 1 0 0 0)]
  (print f"Test 5: {(.encrypt e \"HELLOWORLD\")} expected KZHDFQYHXT"))
