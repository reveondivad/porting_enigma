-- Enigma Cipher - MAXScript
-- 3ds Max scripting language
-- Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
-- PeopleTec Inc. - Guinness World Record Attempt 2026

global fwdI  = #(4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9)
global fwdII = #(0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4)
global fwdIII= #(1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14)
global bwdI  = #(20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9)
global bwdII = #(0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18)
global bwdIII= #(19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12)
global reflector = #(24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19)
global notches = #(16, 4, 21)

fn mod26 n = (
    local m = mod n 26
    if m < 0 then m + 26 else m
)

fn getFwd r i = (
    case r of (
        0: fwdI[i+1]
        1: fwdII[i+1]
        default: fwdIII[i+1]
    )
)

fn getBwd r i = (
    case r of (
        0: bwdI[i+1]
        1: bwdII[i+1]
        default: bwdIII[i+1]
    )
)

fn passFwd rotor offset ch = (
    local inp = mod26 (ch + offset)
    mod26 ((getFwd rotor inp) - offset)
)

fn passBwd rotor offset ch = (
    local inp = mod26 (ch + offset)
    mod26 ((getBwd rotor inp) - offset)
)

struct EnigmaState (r, o, n1, n2)

fn initEnigma r0 r1 r2 k0 k1 k2 = (
    EnigmaState r:#(r0,r1,r2) o:#(k0,k1,k2) n1:(notches[r1+1]) n2:(notches[r2+1])
)

fn stepEnigma e = (
    if e.o[2] == e.n1 then (
        e.o[2] = mod26 (e.o[2]+1); e.o[1] = mod26 (e.o[1]+1)
    ) else if e.o[3] == e.n2 then (
        e.o[2] = mod26 (e.o[2]+1)
    )
    e.o[3] = mod26 (e.o[3]+1)
)

fn pressKey e ch = (
    stepEnigma e
    local c = ch
    c = passFwd e.r[3] e.o[3] c; c = passFwd e.r[2] e.o[2] c; c = passFwd e.r[1] e.o[1] c
    c = reflector[c+1]
    c = passBwd e.r[1] e.o[1] c; c = passBwd e.r[2] e.o[2] c; c = passBwd e.r[3] e.o[3] c
    c
)

print "Enigma Cipher - MAXScript"
-- Test: AAAAA -> BDZGO
