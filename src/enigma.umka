// Enigma Cipher - Umka
// Statically typed embeddable scripting language
// Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
// PeopleTec Inc. - Guinness World Record Attempt 2026

import "std.um"

const (
    fwdI  = [26]int{4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9}
    fwdII = [26]int{0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4}
    fwdIII= [26]int{1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14}
    bwdI  = [26]int{20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9}
    bwdII = [26]int{0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18}
    bwdIII= [26]int{19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12}
    reflector = [26]int{24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19}
    notches = [3]int{16, 4, 21}
)

fn mod26(n: int): int {
    m := n % 26
    if m < 0 { return m + 26 }
    return m
}

fn getFwd(r, i: int): int {
    if r == 0 { return fwdI[i] }
    if r == 1 { return fwdII[i] }
    return fwdIII[i]
}

fn getBwd(r, i: int): int {
    if r == 0 { return bwdI[i] }
    if r == 1 { return bwdII[i] }
    return bwdIII[i]
}

fn passFwd(rotor, offset, ch: int): int { return mod26(getFwd(rotor, mod26(ch+offset)) - offset) }
fn passBwd(rotor, offset, ch: int): int { return mod26(getBwd(rotor, mod26(ch+offset)) - offset) }

type Enigma = struct {
    r: [3]int
    o: [3]int
    n1, n2: int
}

fn newEnigma(r0,r1,r2,k0,k1,k2: int): Enigma {
    return Enigma{[3]int{r0,r1,r2}, [3]int{k0,k1,k2}, notches[r1], notches[r2]}
}

fn (e: ^Enigma) step() {
    if e.o[1] == e.n1 { e.o[1] = mod26(e.o[1]+1); e.o[0] = mod26(e.o[0]+1) }
    else if e.o[2] == e.n2 { e.o[1] = mod26(e.o[1]+1) }
    e.o[2] = mod26(e.o[2]+1)
}

fn (e: ^Enigma) pressKey(ch: int): int {
    e.step()
    c := ch
    c = passFwd(e.r[2],e.o[2],c); c = passFwd(e.r[1],e.o[1],c); c = passFwd(e.r[0],e.o[0],c)
    c = reflector[c]
    c = passBwd(e.r[0],e.o[0],c); c = passBwd(e.r[1],e.o[1],c); c = passBwd(e.r[2],e.o[2],c)
    return c
}

fn (e: ^Enigma) encrypt(msg: str): str {
    result := ""
    for i := 0; i < len(msg); i++ {
        ch := int(msg[i]) - 65
        result += char(e.pressKey(ch) + 65)
    }
    return result
}

fn main() {
    printf("Enigma Cipher - Umka\n")
    e := newEnigma(0,1,2,0,0,0)
    printf("Test 1: %s expected BDZGO\n", e.encrypt("AAAAA"))
    e = newEnigma(0,1,2,0,0,0)
    printf("Test 2: %s expected ILBDAAMTAZ\n", e.encrypt("HELLOWORLD"))
    e = newEnigma(0,1,2,0,0,0)
    printf("Test 3: %s expected BZHGNOCRRTCM\n", e.encrypt("ATTACKATDAWN"))
}
