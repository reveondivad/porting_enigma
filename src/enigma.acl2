; Enigma Cipher - ACL2
; Automated theorem prover for computational logic
; Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
; PeopleTec Inc. - Guinness World Record Attempt 2026

(in-package "ACL2")

(defconst *fwd-I*  '(4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9))
(defconst *fwd-II* '(0 9 3 10 18 8 17 20 23 1 11 7 22 19 12 2 16 6 25 13 15 24 5 21 14 4))
(defconst *fwd-III* '(1 3 5 7 9 11 2 15 17 19 23 21 25 13 24 4 8 22 6 0 10 12 20 18 16 14))
(defconst *bwd-I*  '(20 22 24 6 0 3 5 15 21 25 1 4 2 10 12 19 7 23 18 11 17 8 13 16 14 9))
(defconst *bwd-II* '(0 9 15 2 25 22 17 11 5 1 3 10 14 19 24 20 16 6 4 13 7 23 12 8 21 18))
(defconst *bwd-III* '(19 0 6 1 15 2 18 3 16 4 20 5 21 13 25 7 24 8 23 9 22 11 17 10 14 12))
(defconst *reflector* '(24 17 20 7 16 18 11 3 15 23 13 6 14 10 12 8 4 1 5 25 2 22 21 9 0 19))
(defconst *notches* '(16 4 21))

(defun mod26 (n)
  (declare (xargs :guard (integerp n)))
  (let ((m (mod n 26)))
    (if (< m 0) (+ m 26) m)))

(defun my-nth (i lst)
  (declare (xargs :guard (and (natp i) (true-listp lst))))
  (if (zp i) (car lst) (my-nth (1- i) (cdr lst))))

(defun get-fwd (r i)
  (declare (xargs :guard (and (natp r) (natp i))))
  (cond ((= r 0) (my-nth i *fwd-I*))
        ((= r 1) (my-nth i *fwd-II*))
        (t (my-nth i *fwd-III*))))

(defun get-bwd (r i)
  (declare (xargs :guard (and (natp r) (natp i))))
  (cond ((= r 0) (my-nth i *bwd-I*))
        ((= r 1) (my-nth i *bwd-II*))
        (t (my-nth i *bwd-III*))))

(defun pass-fwd (rotor offset ch)
  (declare (xargs :guard (and (natp rotor) (integerp offset) (integerp ch))))
  (let ((inp (mod26 (+ ch offset))))
    (mod26 (- (get-fwd rotor inp) offset))))

(defun pass-bwd (rotor offset ch)
  (declare (xargs :guard (and (natp rotor) (integerp offset) (integerp ch))))
  (let ((inp (mod26 (+ ch offset))))
    (mod26 (- (get-bwd rotor inp) offset))))

; Test: AAAAA -> BDZGO, HELLOWORLD -> ILBDAAMTAZ
; (pass-fwd 0 0 0) => forward pass through rotor I at offset 0 for character A
