"Enigma Cipher - Smalltalk (enhanced Squeak/Pharo)
 Pure OO programming language
 Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
 PeopleTec Inc. - Guinness World Record Attempt 2026
 .smalltalk2 to differentiate"

Object subclass: #EnigmaMachine
    instanceVariableNames: 'rotors offsets n1 n2'
    classVariableNames: 'FwdI FwdII FwdIII BwdI BwdII BwdIII ReflectorB Notches'
    poolDictionaries: ''
    category: 'Enigma'.

EnigmaMachine class >> initialize [
    FwdI := #(4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9).
    FwdII := #(0 9 3 10 18 8 17 20 23 1 11 7 22 19 12 2 16 6 25 13 15 24 5 21 14 4).
    FwdIII := #(1 3 5 7 9 11 2 15 17 19 23 21 25 13 24 4 8 22 6 0 10 12 20 18 16 14).
    BwdI := #(20 22 24 6 0 3 5 15 21 25 1 4 2 10 12 19 7 23 18 11 17 8 13 16 14 9).
    BwdII := #(0 9 15 2 25 22 17 11 5 1 3 10 14 19 24 20 16 6 4 13 7 23 12 8 21 18).
    BwdIII := #(19 0 6 1 15 2 18 3 16 4 20 5 21 13 25 7 24 8 23 9 22 11 17 10 14 12).
    ReflectorB := #(24 17 20 7 16 18 11 3 15 23 13 6 14 10 12 8 4 1 5 25 2 22 21 9 0 19).
    Notches := #(16 4 21).
]

EnigmaMachine >> mod26: n [
    | m |
    m := n \\ 26.
    ^ m < 0 ifTrue: [m + 26] ifFalse: [m]
]

EnigmaMachine >> getFwd: r at: i [
    r = 0 ifTrue: [^ FwdI at: i + 1].
    r = 1 ifTrue: [^ FwdII at: i + 1].
    ^ FwdIII at: i + 1
]

EnigmaMachine >> getBwd: r at: i [
    r = 0 ifTrue: [^ BwdI at: i + 1].
    r = 1 ifTrue: [^ BwdII at: i + 1].
    ^ BwdIII at: i + 1
]

EnigmaMachine >> passFwd: rotor offset: offset char: ch [
    | inp |
    inp := self mod26: ch + offset.
    ^ self mod26: (self getFwd: rotor at: inp) - offset
]

EnigmaMachine >> passBwd: rotor offset: offset char: ch [
    | inp |
    inp := self mod26: ch + offset.
    ^ self mod26: (self getBwd: rotor at: inp) - offset
]

EnigmaMachine >> initR0: r0 r1: r1 r2: r2 k0: k0 k1: k1 k2: k2 [
    rotors := {r0. r1. r2}.
    offsets := {k0. k1. k2}.
    n1 := Notches at: r1 + 1.
    n2 := Notches at: r2 + 1.
]

EnigmaMachine >> step [
    (offsets at: 2) = n1 ifTrue: [
        offsets at: 2 put: (self mod26: (offsets at: 2) + 1).
        offsets at: 1 put: (self mod26: (offsets at: 1) + 1).
    ] ifFalse: [
        (offsets at: 3) = n2 ifTrue: [
            offsets at: 2 put: (self mod26: (offsets at: 2) + 1).
        ]
    ].
    offsets at: 3 put: (self mod26: (offsets at: 3) + 1).
]

EnigmaMachine >> pressKey: ch [
    | c |
    self step.
    c := ch.
    c := self passFwd: (rotors at: 3) offset: (offsets at: 3) char: c.
    c := self passFwd: (rotors at: 2) offset: (offsets at: 2) char: c.
    c := self passFwd: (rotors at: 1) offset: (offsets at: 1) char: c.
    c := ReflectorB at: c + 1.
    c := self passBwd: (rotors at: 1) offset: (offsets at: 1) char: c.
    c := self passBwd: (rotors at: 2) offset: (offsets at: 2) char: c.
    c := self passBwd: (rotors at: 3) offset: (offsets at: 3) char: c.
    ^ c
]

"Test"
| e |
e := EnigmaMachine new.
e initR0: 0 r1: 1 r2: 2 k0: 0 k1: 0 k2: 0.
Transcript show: 'Enigma Cipher - Smalltalk'; cr.
Transcript show: 'Test: AAAAA -> BDZGO'; cr.
