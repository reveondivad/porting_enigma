-- Enigma Cipher - Eiffel
-- Bertrand Meyer's design-by-contract OOP language
-- Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
-- PeopleTec Inc. - Guinness World Record Attempt 2026

class ENIGMA

create make

feature {NONE} -- Initialization

    fwd: ARRAY [ARRAY [INTEGER]]
    bwd: ARRAY [ARRAY [INTEGER]]
    ref: ARRAY [INTEGER]
    notches: ARRAY [INTEGER]
    r: ARRAY [INTEGER]
    o: ARRAY [INTEGER]
    n1, n2: INTEGER

feature -- Creation

    make (r0, r1, r2, k0, k1, k2: INTEGER)
        do
            create fwd.make_filled (create {ARRAY[INTEGER]}.make_empty, 0, 2)
            fwd[0] := <<4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9>>
            fwd[1] := <<0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4>>
            fwd[2] := <<1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14>>
            create bwd.make_filled (create {ARRAY[INTEGER]}.make_empty, 0, 2)
            bwd[0] := <<20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9>>
            bwd[1] := <<0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18>>
            bwd[2] := <<19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12>>
            ref := <<24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19>>
            notches := <<16, 4, 21>>
            create r.make_filled (0, 0, 2)
            r[0] := r0; r[1] := r1; r[2] := r2
            create o.make_filled (0, 0, 2)
            o[0] := k0; o[1] := k1; o[2] := k2
            n1 := notches[r1]; n2 := notches[r2]
        end

feature -- Operations

    mod26 (n: INTEGER): INTEGER
        local m: INTEGER
        do
            m := n \\ 26
            if m < 0 then m := m + 26 end
            Result := m
        end

    step
        do
            if o[1] = n1 then
                o[1] := mod26(o[1] + 1)
                o[0] := mod26(o[0] + 1)
            elseif o[2] = n2 then
                o[1] := mod26(o[1] + 1)
            end
            o[2] := mod26(o[2] + 1)
        end

    fwd_pass (slot, idx: INTEGER): INTEGER
        local c: INTEGER
        do
            c := mod26(idx + o[slot])
            Result := mod26(fwd[r[slot]][c] - o[slot])
        end

    bwd_pass (slot, idx: INTEGER): INTEGER
        local c: INTEGER
        do
            c := mod26(idx + o[slot])
            Result := mod26(bwd[r[slot]][c] - o[slot])
        end

    press_key (ch: INTEGER): INTEGER
        local c: INTEGER
        do
            step
            c := fwd_pass(2, ch); c := fwd_pass(1, c); c := fwd_pass(0, c)
            c := ref[c]
            c := bwd_pass(0, c); c := bwd_pass(1, c); c := bwd_pass(2, c)
            Result := c
        end

    encrypt (msg: STRING): STRING
        local i, ch: INTEGER
        do
            create Result.make_empty
            from i := 1 until i > msg.count loop
                ch := msg.item(i).code - 65
                Result.append_character ((press_key(ch) + 65).to_character_8)
                i := i + 1
            end
        ensure
            same_length: Result.count = msg.count
        end

end
