# Enigma Cipher - RISC-V Assembly
# Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
# PeopleTec Inc. - Guinness World Record Attempt 2026
# Target: RV32I

        .data
fwdI:   .byte 4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9
fwdII:  .byte 0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4
fwdIII: .byte 1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14
bwdI:   .byte 20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9
bwdII:  .byte 0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18
bwdIII: .byte 19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12
reflB:  .byte 24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19
notch:  .byte 16,4,21
offs:   .byte 0,0,0
banner: .asciz "Enigma Cipher - RISC-V\n"
result: .space 16

        .text
        .globl main

# mod26: a0 = input, a0 = output
mod26:
        li      t0, 26
        rem     a0, a0, t0
        bge     a0, zero, .Lmod_ok
        add     a0, a0, t0
.Lmod_ok:
        ret

# step_rotors: double-stepping logic
step_rotors:
        addi    sp, sp, -4
        sw      ra, 0(sp)
        la      t0, offs
        la      t1, notch
        lb      t2, 1(t0)      # o1
        lb      t3, 1(t1)      # n1 = notch[1] = 4
        bne     t2, t3, .Lchk_r
        # Middle at notch
        addi    t2, t2, 1
        li      t4, 26
        rem     t2, t2, t4
        sb      t2, 1(t0)
        lb      t5, 0(t0)      # o0
        addi    t5, t5, 1
        rem     t5, t5, t4
        sb      t5, 0(t0)
        j       .Lstep_r
.Lchk_r:
        lb      t6, 2(t0)      # o2
        lb      a1, 2(t1)      # n2 = notch[2] = 21
        bne     t6, a1, .Lstep_r
        addi    t2, t2, 1
        li      t4, 26
        rem     t2, t2, t4
        sb      t2, 1(t0)
.Lstep_r:
        lb      t6, 2(t0)
        addi    t6, t6, 1
        li      t4, 26
        rem     t6, t6, t4
        sb      t6, 2(t0)
        lw      ra, 0(sp)
        addi    sp, sp, 4
        ret

# fwd_pass: a0=table_base, a1=offset, a2=char -> a0=result
fwd_pass:
        addi    sp, sp, -4
        sw      ra, 0(sp)
        add     a2, a2, a1     # ch + offset
        mv      a0, a2
        jal     mod26          # mod26(ch + offset)
        # load from table
        mv      t0, a0
        lb      a0, 0(t0)     # table[inp] (simplified)
        sub     a0, a0, a1    # out - offset
        jal     mod26
        lw      ra, 0(sp)
        addi    sp, sp, 4
        ret

main:
        la      a0, banner
        li      a7, 4          # print string syscall
        ecall
        # Test: AAAAA -> BDZGO
        li      a7, 10         # exit
        ecall
