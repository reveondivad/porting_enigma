;; Enigma cipher in Gerbil Scheme
(import :std/iter :std/text/char-set)

(def rotor-fwd
  #(#(4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9)
    #(0 9 3 10 18 8 17 20 23 1 11 7 22 19 12 2 16 6 25 13 15 24 5 21 14 4)
    #(1 3 5 7 9 11 2 15 17 19 23 21 25 13 24 4 8 22 6 0 10 12 20 18 16 14)))

(def rotor-bwd
  #(#(20 22 24 6 0 3 5 15 21 25 1 4 2 10 12 19 7 23 18 11 17 8 13 16 14 9)
    #(0 9 15 2 25 22 17 11 5 1 3 10 14 19 24 20 16 6 4 13 7 23 12 8 21 18)
    #(19 0 6 1 15 2 18 3 16 4 20 5 21 13 25 7 24 8 23 9 22 11 17 10 14 12)))

(def reflector #(24 17 20 7 16 18 11 3 15 23 13 6 14 10 12 8 4 1 5 25 2 22 21 9 0 19))
(def notches #(16 4 21))

(def (mod26 n) (modulo (+ (modulo n 26) 26) 26))

(def (rotor-pass wiring c pos)
  (mod26 (- (vector-ref wiring (mod26 (+ c pos))) pos)))

(def (enigma text)
  (let ((pos (vector 0 0 0))
        (result '()))
    (for-each
      (lambda (ch)
        (let ((c (- (char->integer (char-upcase ch)) 65)))
          (when (and (>= c 0) (< c 26))
            (let ((mid (= (vector-ref pos 1) (vector-ref notches 1))))
              (when (= (vector-ref pos 2) (vector-ref notches 2))
                (vector-set! pos 2 (mod26 (+ (vector-ref pos 2) 1))))
              (when (or mid (= (vector-ref pos 2) (vector-ref notches 2)))
                (vector-set! pos 1 (mod26 (+ (vector-ref pos 1) 1))))
              (vector-set! pos 2 (mod26 (+ (vector-ref pos 2) 1))))
            (let loop ((c c) (i 2))
              (if (< i 0) c
                (loop (rotor-pass (vector-ref rotor-fwd i) c (vector-ref pos i)) (- i 1))))
            => (lambda (c)
              (set! c (vector-ref reflector c))
              (let loop2 ((c c) (i 0))
                (if (> i 2)
                  (set! result (cons (integer->char (+ c 65)) result))
                  (loop2 (rotor-pass (vector-ref rotor-bwd i) c (vector-ref pos i)) (+ i 1))))))))
      (string->list text))
    (list->string (reverse result))))

(displayln (enigma "HELLOWORLD"))
