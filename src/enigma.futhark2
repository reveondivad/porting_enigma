-- Enigma Cipher - Futhark (enhanced version)
-- Purely functional data-parallel language for GPU
-- Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
-- PeopleTec Inc. - Guinness World Record Attempt 2026
-- .futhark2 to avoid collision

let fwd_i : [26]i32 = [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9]
let fwd_ii : [26]i32 = [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4]
let fwd_iii : [26]i32 = [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14]
let bwd_i : [26]i32 = [20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9]
let bwd_ii : [26]i32 = [0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18]
let bwd_iii : [26]i32 = [19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12]
let reflector : [26]i32 = [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19]
let notches : [3]i32 = [16, 4, 21]

let mod26 (n: i32) : i32 =
  let m = n %% 26 in if m < 0 then m + 26 else m

let get_fwd (r: i32) (i: i32) : i32 =
  if r == 0 then fwd_i[i] else if r == 1 then fwd_ii[i] else fwd_iii[i]

let get_bwd (r: i32) (i: i32) : i32 =
  if r == 0 then bwd_i[i] else if r == 1 then bwd_ii[i] else bwd_iii[i]

let pass_fwd (rotor: i32) (offset: i32) (ch: i32) : i32 =
  let inp = mod26 (ch + offset) in mod26 (get_fwd rotor inp - offset)

let pass_bwd (rotor: i32) (offset: i32) (ch: i32) : i32 =
  let inp = mod26 (ch + offset) in mod26 (get_bwd rotor inp - offset)

-- Sequential encryption for correctness (double-stepping)
let encrypt [n] (r: [3]i32) (k: [3]i32) (msg: [n]i32) : [n]i32 =
  let (_, _, result) =
    loop (o, _, out) = (k, 0i32, replicate n 0i32) for i < n do
      let o1 = if o[1] == notches[r[1]] then (mod26 (o[1]+1)) else o[1]
      let o0 = if o[1] == notches[r[1]] then (mod26 (o[0]+1)) else o[0]
      let o1b = if o[2] == notches[r[2]] && o[1] != notches[r[1]] then (mod26 (o[1]+1)) else o1
      let o2 = mod26 (o[2]+1)
      let c = msg[i]
      let c = pass_fwd r[2] o2 c
      let c = pass_fwd r[1] o1b c
      let c = pass_fwd r[0] o0 c
      let c = reflector[c]
      let c = pass_bwd r[0] o0 c
      let c = pass_bwd r[1] o1b c
      let c = pass_bwd r[2] o2 c
      let out = out with [i] = c
      in ([o0, o1b, o2], 0i32, out)
  in result

-- Test: AAAAA -> BDZGO
entry main : []i32 = encrypt [0,1,2] [0,0,0] [0,0,0,0,0]
