(* Enigma Cipher - Eff *)
(* Algebraic effects programming language *)
(* Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping *)
(* PeopleTec Inc. - Guinness World Record Attempt 2026 *)

let fwd_i  = [|4;10;12;5;11;6;3;16;21;25;13;19;14;22;24;7;23;20;18;15;0;8;1;17;2;9|]
let fwd_ii = [|0;9;3;10;18;8;17;20;23;1;11;7;22;19;12;2;16;6;25;13;15;24;5;21;14;4|]
let fwd_iii= [|1;3;5;7;9;11;2;15;17;19;23;21;25;13;24;4;8;22;6;0;10;12;20;18;16;14|]
let bwd_i  = [|20;22;24;6;0;3;5;15;21;25;1;4;2;10;12;19;7;23;18;11;17;8;13;16;14;9|]
let bwd_ii = [|0;9;15;2;25;22;17;11;5;1;3;10;14;19;24;20;16;6;4;13;7;23;12;8;21;18|]
let bwd_iii= [|19;0;6;1;15;2;18;3;16;4;20;5;21;13;25;7;24;8;23;9;22;11;17;10;14;12|]
let reflector = [|24;17;20;7;16;18;11;3;15;23;13;6;14;10;12;8;4;1;5;25;2;22;21;9;0;19|]
let notches = [|16; 4; 21|]

let mod26 n =
  let m = n mod 26 in
  if m < 0 then m + 26 else m

let get_fwd r i = match r with
  | 0 -> fwd_i.(i)
  | 1 -> fwd_ii.(i)
  | _ -> fwd_iii.(i)

let get_bwd r i = match r with
  | 0 -> bwd_i.(i)
  | 1 -> bwd_ii.(i)
  | _ -> bwd_iii.(i)

let pass_fwd rotor offset ch =
  let inp = mod26 (ch + offset) in
  let out = get_fwd rotor inp in
  mod26 (out - offset)

let pass_bwd rotor offset ch =
  let inp = mod26 (ch + offset) in
  let out = get_bwd rotor inp in
  mod26 (out - offset)

(* Use mutable state effect for rotor positions *)
effect State : sig
  val get_o : int -> int
  val set_o : int -> int -> unit
end

let r = ref [|0;1;2|]
let o = ref [|0;0;0|]
let n = ref [|4;21|]

let init_enigma r0 r1 r2 k0 k1 k2 =
  r := [|r0;r1;r2|];
  o := [|k0;k1;k2|];
  n := [|notches.(r1); notches.(r2)|]

let step () =
  let ov = !o in
  let nv = !n in
  if ov.(1) = nv.(0) then begin
    ov.(1) <- mod26 (ov.(1) + 1);
    ov.(0) <- mod26 (ov.(0) + 1)
  end else if ov.(2) = nv.(1) then
    ov.(1) <- mod26 (ov.(1) + 1);
  ov.(2) <- mod26 (ov.(2) + 1)

let press_key ch =
  step ();
  let rv = !r in let ov = !o in
  let c = ref ch in
  c := pass_fwd rv.(2) ov.(2) !c;
  c := pass_fwd rv.(1) ov.(1) !c;
  c := pass_fwd rv.(0) ov.(0) !c;
  c := reflector.(!c);
  c := pass_bwd rv.(0) ov.(0) !c;
  c := pass_bwd rv.(1) ov.(1) !c;
  c := pass_bwd rv.(2) ov.(2) !c;
  !c

let encrypt msg =
  let len = String.length msg in
  let buf = Buffer.create len in
  for i = 0 to len - 1 do
    let ch = Char.code (String.get msg i) - 65 in
    Buffer.add_char buf (Char.chr (press_key ch + 65))
  done;
  Buffer.contents buf

let () =
  print_string "Enigma Cipher - Eff\n";
  init_enigma 0 1 2 0 0 0; print_string ("Test 1: " ^ encrypt "AAAAA" ^ " expected BDZGO\n");
  init_enigma 0 1 2 0 0 0; print_string ("Test 2: " ^ encrypt "HELLOWORLD" ^ " expected ILBDAAMTAZ\n");
  init_enigma 0 1 2 0 0 0; print_string ("Test 3: " ^ encrypt "ATTACKATDAWN" ^ " expected BZHGNOCRRTCM\n")
