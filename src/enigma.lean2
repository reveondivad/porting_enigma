/- Enigma Cipher - Lean 4
   Theorem prover and programming language
   Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
   PeopleTec Inc. - Guinness World Record Attempt 2026
   .lean2 to avoid collision -/

def fwdI : Array Int := #[4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9]
def fwdII : Array Int := #[0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4]
def fwdIII : Array Int := #[1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14]
def bwdI : Array Int := #[20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9]
def bwdII : Array Int := #[0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18]
def bwdIII : Array Int := #[19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12]
def reflector : Array Int := #[24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19]
def notches : Array Int := #[16, 4, 21]

def mod26 (n : Int) : Int :=
  let m := n % 26
  if m < 0 then m + 26 else m

def getFwd (r : Int) (i : Nat) : Int :=
  match r with
  | 0 => fwdI.get! i
  | 1 => fwdII.get! i
  | _ => fwdIII.get! i

def getBwd (r : Int) (i : Nat) : Int :=
  match r with
  | 0 => bwdI.get! i
  | 1 => bwdII.get! i
  | _ => bwdIII.get! i

def passFwd (rotor : Int) (offset : Int) (ch : Int) : Int :=
  let inp := (mod26 (ch + offset)).toNat
  mod26 (getFwd rotor inp - offset)

def passBwd (rotor : Int) (offset : Int) (ch : Int) : Int :=
  let inp := (mod26 (ch + offset)).toNat
  mod26 (getBwd rotor inp - offset)

structure EnigmaState where
  r : Array Int
  o : Array Int
  n1 : Int
  n2 : Int

def initEnigma (r0 r1 r2 k0 k1 k2 : Int) : EnigmaState :=
  { r := #[r0, r1, r2], o := #[k0, k1, k2],
    n1 := notches.get! r1.toNat, n2 := notches.get! r2.toNat }

def step (s : EnigmaState) : EnigmaState :=
  let o := s.o
  if o.get! 1 == s.n1 then
    { s with o := #[mod26 (o.get! 0 + 1), mod26 (o.get! 1 + 1), mod26 (o.get! 2 + 1)] }
  else if o.get! 2 == s.n2 then
    { s with o := #[o.get! 0, mod26 (o.get! 1 + 1), mod26 (o.get! 2 + 1)] }
  else
    { s with o := #[o.get! 0, o.get! 1, mod26 (o.get! 2 + 1)] }

def pressKey (s : EnigmaState) (ch : Int) : (EnigmaState × Int) :=
  let s := step s
  let c := passFwd (s.r.get! 2) (s.o.get! 2) ch
  let c := passFwd (s.r.get! 1) (s.o.get! 1) c
  let c := passFwd (s.r.get! 0) (s.o.get! 0) c
  let c := reflector.get! c.toNat
  let c := passBwd (s.r.get! 0) (s.o.get! 0) c
  let c := passBwd (s.r.get! 1) (s.o.get! 1) c
  let c := passBwd (s.r.get! 2) (s.o.get! 2) c
  (s, c)

def encrypt (r0 r1 r2 k0 k1 k2 : Int) (msg : String) : String :=
  let s := initEnigma r0 r1 r2 k0 k1 k2
  let (_, result) := msg.foldl (fun (acc : EnigmaState × String) c =>
    let ch := c.toNat - 65
    let (s', enc) := pressKey acc.1 ch
    (s', acc.2 ++ String.singleton (Char.ofNat (enc.toNat + 65)))
  ) (s, "")
  result

def main : IO Unit := do
  IO.println "Enigma Cipher - Lean 4"
  IO.println s!"Test 1: {encrypt 0 1 2 0 0 0 "AAAAA"} expected BDZGO"
  IO.println s!"Test 2: {encrypt 0 1 2 0 0 0 "HELLOWORLD"} expected ILBDAAMTAZ"
  IO.println s!"Test 3: {encrypt 0 1 2 0 0 0 "ATTACKATDAWN"} expected BZHGNOCRRTCM"
