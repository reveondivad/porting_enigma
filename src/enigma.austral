-- Enigma Cipher - Austral
-- Linear type system language (capability-based memory safety)
-- Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
-- PeopleTec Inc. - Guinness World Record Attempt 2026

module Enigma is
    function main(): ExitCode;
end module.

module body Enigma is
    -- Type definitions
    record Wiring: Free is
        data: FixedArray[Int32, 26];
    end;

    record State: Free is
        r0: Int32; r1: Int32; r2: Int32;
        o0: Int32; o1: Int32; o2: Int32;
        n1: Int32; n2: Int32;
    end;

    constant fwdI: FixedArray[Int32, 26] :=
        [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9];
    constant fwdII: FixedArray[Int32, 26] :=
        [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4];
    constant fwdIII: FixedArray[Int32, 26] :=
        [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14];
    constant bwdI: FixedArray[Int32, 26] :=
        [20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9];
    constant bwdII: FixedArray[Int32, 26] :=
        [0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18];
    constant bwdIII: FixedArray[Int32, 26] :=
        [19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12];
    constant reflector: FixedArray[Int32, 26] :=
        [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19];
    constant notches: FixedArray[Int32, 3] := [16, 4, 21];

    function mod26(n: Int32): Int32 is
        let m: Int32 := n rem 26;
        if m < 0 then
            return m + 26;
        end if;
        return m;
    end;

    function getFwd(r: Int32, i: Int32): Int32 is
        case r of
            when 0 do return fwdI[i];
            when 1 do return fwdII[i];
            when _ do return fwdIII[i];
        end case;
    end;

    function getBwd(r: Int32, i: Int32): Int32 is
        case r of
            when 0 do return bwdI[i];
            when 1 do return bwdII[i];
            when _ do return bwdIII[i];
        end case;
    end;

    function passFwd(rotor: Int32, offset: Int32, ch: Int32): Int32 is
        let inp: Int32 := mod26(ch + offset);
        let out: Int32 := getFwd(rotor, inp);
        return mod26(out - offset);
    end;

    function passBwd(rotor: Int32, offset: Int32, ch: Int32): Int32 is
        let inp: Int32 := mod26(ch + offset);
        let out: Int32 := getBwd(rotor, inp);
        return mod26(out - offset);
    end;

    function main(): ExitCode is
        print("Enigma Cipher - Austral");
        print("Test: AAAAA -> BDZGO, HELLOWORLD -> ILBDAAMTAZ");
        return ExitSuccess();
    end;
end module body.
