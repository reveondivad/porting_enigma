-- Enigma Cipher - Futhark
-- Purely functional data-parallel programming language for GPU
-- Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
-- PeopleTec Inc. - Guinness World Record Attempt 2026

let fwd_i: [26]i32 = [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9]
let fwd_ii: [26]i32 = [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4]
let fwd_iii: [26]i32 = [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14]
let bwd_i: [26]i32 = [20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9]
let bwd_ii: [26]i32 = [0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18]
let bwd_iii: [26]i32 = [19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12]
let reflector_b: [26]i32 = [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19]
let notches: [3]i32 = [16, 4, 21]

let mod26 (n: i32): i32 =
  let m = n %% 26
  in if m < 0 then m + 26 else m

let get_fwd (r: i32) (i: i32): i32 =
  if r == 0 then fwd_i[i]
  else if r == 1 then fwd_ii[i]
  else fwd_iii[i]

let get_bwd (r: i32) (i: i32): i32 =
  if r == 0 then bwd_i[i]
  else if r == 1 then bwd_ii[i]
  else bwd_iii[i]

let pass_fwd (rotor: i32) (offset: i32) (ch: i32): i32 =
  let inp = mod26(ch + offset)
  in mod26(get_fwd rotor inp - offset)

let pass_bwd (rotor: i32) (offset: i32) (ch: i32): i32 =
  let inp = mod26(ch + offset)
  in mod26(get_bwd rotor inp - offset)

-- Encrypt a sequence of characters (as i32 values 0-25)
-- Sequential due to rotor state dependency
let encrypt [n] (rotors: [3]i32) (keys: [3]i32) (msg: [n]i32): [n]i32 =
  let n1 = notches[rotors[1]]
  let n2 = notches[rotors[2]]
  let (_, result) =
    loop (o, res) = (keys, replicate n 0i32) for i < n do
      -- Step
      let o = if o[1] == n1 then [mod26(o[0]+1), mod26(o[1]+1), o[2]]
              else if o[2] == n2 then [o[0], mod26(o[1]+1), o[2]]
              else o
      let o = [o[0], o[1], mod26(o[2]+1)]
      -- Forward
      let c = msg[i]
      let c = pass_fwd rotors[2] o[2] c
      let c = pass_fwd rotors[1] o[1] c
      let c = pass_fwd rotors[0] o[0] c
      let c = reflector_b[c]
      let c = pass_bwd rotors[0] o[0] c
      let c = pass_bwd rotors[1] o[1] c
      let c = pass_bwd rotors[2] o[2] c
      let res = res with [i] = c
      in (o, res)
  in result

-- Test: encrypt [0,1,2] [0,0,0] [0,0,0,0,0] => [1,3,25,6,14] (BDZGO)
entry main: []i32 =
  encrypt [0,1,2] [0,0,0] [0,0,0,0,0]
