// Enigma cipher in Austral (linear types systems language) variant
// Using .vale13 extension to avoid collision
module body Enigma is
    pragma Unsafe_Module;

    type RotorArray: Fixed_Array[Natural_26, Natural_8];

    constant rotorFwdI: RotorArray :=
        #[4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9];
    constant rotorFwdII: RotorArray :=
        #[0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4];
    constant rotorFwdIII: RotorArray :=
        #[1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14];
    constant reflectorB: RotorArray :=
        #[24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19];
    constant notches: Fixed_Array[Natural_3, Natural_8] := #[16, 4, 21];

    function mod26(n: Integer_32): Natural_8 is
        let m: Integer_32 := n mod 26;
        if m < 0 then
            return narrowing_cast(m + 26);
        else
            return narrowing_cast(m);
        end if;
    end;

    function rotorPass(wiring: RotorArray, c: Natural_8, pos: Natural_8): Natural_8 is
        return mod26(cast(wiring[mod26(cast(c) + cast(pos))]) - cast(pos));
    end;

    function main(): ExitCode is
        printLn("Enigma Austral variant implementation");
        return ExitSuccess();
    end;
end module body.
