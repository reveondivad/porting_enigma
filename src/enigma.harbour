// Enigma Cipher - Harbour (xBase/Clipper successor)
// dBASE-compatible language for business applications
// Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
// PeopleTec Inc. - Guinness World Record Attempt 2026

#include "hbclass.ch"

STATIC aFwdI  := {4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9}
STATIC aFwdII := {0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4}
STATIC aFwdIII:= {1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14}
STATIC aBwdI  := {20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9}
STATIC aBwdII := {0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18}
STATIC aBwdIII:= {19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12}
STATIC aRef   := {24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19}
STATIC aNotch := {16, 4, 21}

STATIC aR, aO, nN1, nN2

FUNCTION Main()
   ? "Enigma Cipher - Harbour"
   InitEnigma(0, 1, 2, 0, 0, 0)
   ? "Test 1: " + Encrypt("AAAAA") + " expected BDZGO"
   InitEnigma(0, 1, 2, 0, 0, 0)
   ? "Test 2: " + Encrypt("HELLOWORLD") + " expected ILBDAAMTAZ"
   InitEnigma(0, 1, 2, 0, 0, 0)
   ? "Test 3: " + Encrypt("ATTACKATDAWN") + " expected BZHGNOCRRTCM"
   InitEnigma(0, 1, 2, 12, 2, 10)
   ? "Test 4: " + Encrypt("HELLOWORLD") + " expected DLTBBQVPQV"
   InitEnigma(2, 0, 1, 0, 0, 0)
   ? "Test 5: " + Encrypt("HELLOWORLD") + " expected KZHDFQYHXT"
   RETURN NIL

FUNCTION Mod26(n)
   LOCAL m := n % 26
   IF m < 0; m += 26; ENDIF
   RETURN m

FUNCTION InitEnigma(r0, r1, r2, k0, k1, k2)
   aR := {r0, r1, r2}
   aO := {k0, k1, k2}
   nN1 := aNotch[r1 + 1]  // Harbour is 1-indexed
   nN2 := aNotch[r2 + 1]
   RETURN NIL

FUNCTION GetFwd(r, i)
   DO CASE
   CASE r == 0; RETURN aFwdI[i + 1]
   CASE r == 1; RETURN aFwdII[i + 1]
   OTHERWISE;   RETURN aFwdIII[i + 1]
   ENDCASE

FUNCTION GetBwd(r, i)
   DO CASE
   CASE r == 0; RETURN aBwdI[i + 1]
   CASE r == 1; RETURN aBwdII[i + 1]
   OTHERWISE;   RETURN aBwdIII[i + 1]
   ENDCASE

FUNCTION PassFwd(rotor, offset, ch)
   LOCAL inp := Mod26(ch + offset)
   RETURN Mod26(GetFwd(rotor, inp) - offset)

FUNCTION PassBwd(rotor, offset, ch)
   LOCAL inp := Mod26(ch + offset)
   RETURN Mod26(GetBwd(rotor, inp) - offset)

FUNCTION StepRotors()
   IF aO[2] == nN1
      aO[2] := Mod26(aO[2] + 1)
      aO[1] := Mod26(aO[1] + 1)
   ELSEIF aO[3] == nN2
      aO[2] := Mod26(aO[2] + 1)
   ENDIF
   aO[3] := Mod26(aO[3] + 1)
   RETURN NIL

FUNCTION PressKey(ch)
   LOCAL c
   StepRotors()
   c := PassFwd(aR[3], aO[3], ch)
   c := PassFwd(aR[2], aO[2], c)
   c := PassFwd(aR[1], aO[1], c)
   c := aRef[c + 1]
   c := PassBwd(aR[1], aO[1], c)
   c := PassBwd(aR[2], aO[2], c)
   c := PassBwd(aR[3], aO[3], c)
   RETURN c

FUNCTION Encrypt(cMsg)
   LOCAL cResult := "", i, nCh
   FOR i := 1 TO Len(cMsg)
      nCh := Asc(SubStr(cMsg, i, 1)) - 65
      cResult += Chr(PressKey(nCh) + 65)
   NEXT
   RETURN cResult
