; Enigma Cipher - Motorola 68000 Assembly
; Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
; PeopleTec Inc. - Guinness World Record Attempt 2026
; Target: Amiga / Atari ST / Sega Genesis

        section .text
        org     $1000

; ---- Data Section ----
fwdI:   dc.b 4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9
fwdII:  dc.b 0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4
fwdIII: dc.b 1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14
bwdI:   dc.b 20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9
bwdII:  dc.b 0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18
bwdIII: dc.b 19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12
reflB:  dc.b 24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19
notch:  dc.b 16,4,21

; State variables
rotors: dc.b 0,1,2       ; rotor selection
offsets:dc.b 0,0,0       ; current rotor positions
npos:   dc.b 4,21        ; notch positions for middle/right

; ---- mod26 subroutine ----
; Input: D0.W = value
; Output: D0.W = value mod 26 (non-negative)
mod26:
        ext.l   d0
        divs    #26,d0
        swap    d0            ; remainder in high word
        ext.w   d0
        tst.w   d0
        bge.s   .pos
        add.w   #26,d0
.pos:   rts

; ---- Forward pass through one rotor ----
; Input: A0 = rotor table, D0.W = offset, D1.W = char
; Output: D1.W = result
fwd_pass:
        add.w   d0,d1         ; ch + offset
        move.w  d1,d0
        bsr.s   mod26         ; mod26(ch + offset)
        move.w  d0,d1
        move.b  (a0,d1.w),d1  ; rotor lookup
        ext.w   d1
        move.w  offsets,d0    ; restore offset for subtraction
        sub.w   d0,d1         ; out - offset
        move.w  d1,d0
        bsr.s   mod26
        move.w  d0,d1
        rts

; ---- Step rotors (double-stepping) ----
step_rotors:
        move.b  offsets+1,d0  ; middle offset
        ext.w   d0
        cmp.b   npos,d0      ; compare with middle notch
        bne.s   .check_right
        ; Middle at notch: step middle and left
        addq.b  #1,offsets+1
        move.b  offsets+1,d0
        ext.w   d0
        bsr.s   mod26
        move.b  d0,offsets+1
        addq.b  #1,offsets
        move.b  offsets,d0
        ext.w   d0
        bsr.s   mod26
        move.b  d0,offsets
        bra.s   .step_right
.check_right:
        move.b  offsets+2,d0  ; right offset
        ext.w   d0
        cmp.b   npos+1,d0    ; compare with right notch
        bne.s   .step_right
        ; Right at notch: step middle
        addq.b  #1,offsets+1
        move.b  offsets+1,d0
        ext.w   d0
        bsr.s   mod26
        move.b  d0,offsets+1
.step_right:
        addq.b  #1,offsets+2
        move.b  offsets+2,d0
        ext.w   d0
        bsr.s   mod26
        move.b  d0,offsets+2
        rts

; ---- Press key ----
; Input: D1.W = plaintext char (0-25)
; Output: D1.W = ciphertext char (0-25)
press_key:
        bsr.s   step_rotors
        ; Forward through III, II, I
        lea     fwdIII,a0
        move.b  offsets+2,d0
        ext.w   d0
        bsr.s   fwd_pass
        lea     fwdII,a0
        move.b  offsets+1,d0
        ext.w   d0
        bsr.s   fwd_pass
        lea     fwdI,a0
        move.b  offsets,d0
        ext.w   d0
        bsr.s   fwd_pass
        ; Reflector
        lea     reflB,a0
        move.b  (a0,d1.w),d1
        ext.w   d1
        ; Backward through I, II, III
        lea     bwdI,a0
        move.b  offsets,d0
        ext.w   d0
        bsr.s   fwd_pass      ; reuse fwd_pass with bwd table
        lea     bwdII,a0
        move.b  offsets+1,d0
        ext.w   d0
        bsr.s   fwd_pass
        lea     bwdIII,a0
        move.b  offsets+2,d0
        ext.w   d0
        bsr.s   fwd_pass
        rts

; Entry: Test AAAAA -> BDZGO
start:
        moveq   #4,d7         ; 5 chars
        lea     result,a1
.loop:  moveq   #0,d1         ; 'A' = 0
        bsr.s   press_key
        add.b   #65,d1        ; convert to ASCII
        move.b  d1,(a1)+
        dbra    d7,.loop
        rts

result: ds.b    16            ; output buffer
        even
        end
