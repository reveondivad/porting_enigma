# Enigma Cipher - Scopes
# Retargetable meta-language (LLVM, SPIR-V)
# Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
# PeopleTec Inc. - Guinness World Record Attempt 2026

using import Array
using import String

global fwd-I = (arrayof i32 4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9)
global fwd-II = (arrayof i32 0 9 3 10 18 8 17 20 23 1 11 7 22 19 12 2 16 6 25 13 15 24 5 21 14 4)
global fwd-III = (arrayof i32 1 3 5 7 9 11 2 15 17 19 23 21 25 13 24 4 8 22 6 0 10 12 20 18 16 14)
global bwd-I = (arrayof i32 20 22 24 6 0 3 5 15 21 25 1 4 2 10 12 19 7 23 18 11 17 8 13 16 14 9)
global bwd-II = (arrayof i32 0 9 15 2 25 22 17 11 5 1 3 10 14 19 24 20 16 6 4 13 7 23 12 8 21 18)
global bwd-III = (arrayof i32 19 0 6 1 15 2 18 3 16 4 20 5 21 13 25 7 24 8 23 9 22 11 17 10 14 12)
global reflector = (arrayof i32 24 17 20 7 16 18 11 3 15 23 13 6 14 10 12 8 4 1 5 25 2 22 21 9 0 19)
global notches = (arrayof i32 16 4 21)

fn mod26 (n)
    let m = (n % 26)
    if (m < 0) (m + 26) else m

fn get-fwd (r i)
    switch r
    case 0 (fwd-I @ i)
    case 1 (fwd-II @ i)
    default (fwd-III @ i)

fn get-bwd (r i)
    switch r
    case 0 (bwd-I @ i)
    case 1 (bwd-II @ i)
    default (bwd-III @ i)

fn pass-fwd (rotor offset ch)
    let inp = (mod26 (ch + offset))
    let out = (get-fwd rotor inp)
    mod26 (out - offset)

fn pass-bwd (rotor offset ch)
    let inp = (mod26 (ch + offset))
    let out = (get-bwd rotor inp)
    mod26 (out - offset)

# Test: AAAAA -> BDZGO, HELLOWORLD -> ILBDAAMTAZ
print "Enigma Cipher - Scopes"
