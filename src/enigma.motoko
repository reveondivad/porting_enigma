// Enigma cipher in Motoko (Internet Computer / DFINITY)
import Array "mo:base/Array";
import Char "mo:base/Char";
import Nat "mo:base/Nat";
import Text "mo:base/Text";
import Iter "mo:base/Iter";
import Buffer "mo:base/Buffer";

actor Enigma {
  let rotorFwd : [[Nat]] = [
    [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9],
    [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4],
    [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14]
  ];
  let rotorBwd : [[Nat]] = [
    [20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9],
    [0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18],
    [19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12]
  ];
  let reflector : [Nat] = [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19];
  let notches : [Nat] = [16,4,21];

  func mod26(n : Int) : Nat { let m = n % 26; if (m < 0) { Nat.abs(m + 26) } else { Nat.abs(m) } };

  public func encrypt(text : Text) : async Text {
    var pos : [var Nat] = [var 0, 0, 0];
    let buf = Buffer.Buffer<Char>(text.size());
    for (ch in text.chars()) {
      let upper = Char.toUpper(ch);
      if (upper >= 'A' and upper <= 'Z') {
        let mid = pos[1] == notches[1];
        if (pos[2] == notches[2]) { pos[2] := mod26(pos[2] + 1) };
        if (mid or pos[2] == notches[2]) { pos[1] := mod26(pos[1] + 1) };
        pos[2] := mod26(pos[2] + 1);
        var c = Nat.sub(Char.toNat32(upper), 65);
        var i : Int = 2;
        while (i >= 0) {
          c := mod26(rotorFwd[Nat.abs(i)][mod26(c + pos[Nat.abs(i)])] - pos[Nat.abs(i)]);
          i -= 1;
        };
        c := reflector[c];
        i := 0;
        while (i <= 2) {
          c := mod26(rotorBwd[Nat.abs(i)][mod26(c + pos[Nat.abs(i)])] - pos[Nat.abs(i)]);
          i += 1;
        };
        buf.add(Char.fromNat32(Nat.toNat32(c) + 65));
      };
    };
    Text.fromIter(buf.vals())
  };
};
