// Enigma cipher in Sophia (Aeternity blockchain smart contract)
@compiler >= 6
contract Enigma =
  type state = { pos : list(int) }

  entrypoint init() = { pos = [0, 0, 0] }

  function mod26(n : int) : int =
    let m = n mod 26
    if(m < 0) m + 26 else m

  function rotor_fwd_1() : list(int) =
    [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9]
  function rotor_fwd_2() : list(int) =
    [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4]
  function rotor_fwd_3() : list(int) =
    [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14]
  function reflector_b() : list(int) =
    [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19]

  function nth(lst : list(int), idx : int) : int =
    switch(lst)
      [] => 0
      h :: t => if(idx == 0) h else nth(t, idx - 1)

  function rotor_pass(wiring : list(int), c : int, p : int) : int =
    mod26(nth(wiring, mod26(c + p)) - p)

  stateful entrypoint encrypt_char(c : int) : int =
    let c1 = rotor_pass(rotor_fwd_3(), c, nth(state.pos, 2))
    let c2 = rotor_pass(rotor_fwd_2(), c1, nth(state.pos, 1))
    let c3 = rotor_pass(rotor_fwd_1(), c2, nth(state.pos, 0))
    nth(reflector_b(), c3)
