-- Enigma Cipher - MoonScript (enhanced version)
-- Lua-targeting language with CoffeeScript-like syntax
-- Wehrmacht Enigma I - PeopleTec Inc. 2026 .moonscript2 to avoid collision

fwd_i  = {4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9}
fwd_ii = {0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4}
fwd_iii= {1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14}
bwd_i  = {20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9}
bwd_ii = {0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18}
bwd_iii= {19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12}
reflector = {24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19}
notches = {16, 4, 21}

mod26 = (n) -> m = n % 26; if m < 0 then m + 26 else m
get_fwd = (r, i) -> switch r
  when 0 then fwd_i[i+1]
  when 1 then fwd_ii[i+1]
  else fwd_iii[i+1]
get_bwd = (r, i) -> switch r
  when 0 then bwd_i[i+1]
  when 1 then bwd_ii[i+1]
  else bwd_iii[i+1]
pass_fwd = (rotor, offset, ch) -> mod26(get_fwd(rotor, mod26(ch+offset)) - offset)
pass_bwd = (rotor, offset, ch) -> mod26(get_bwd(rotor, mod26(ch+offset)) - offset)

encrypt = (r0,r1,r2,k0,k1,k2,msg) ->
  r = {r0,r1,r2}
  o = {k0,k1,k2}
  n1 = notches[r[2]+1]
  n2 = notches[r[3]+1]
  result = ""
  for i = 1, #msg
    if o[2] == n1
      o[2] = mod26(o[2]+1)
      o[1] = mod26(o[1]+1)
    elseif o[3] == n2
      o[2] = mod26(o[2]+1)
    o[3] = mod26(o[3]+1)
    c = string.byte(msg, i) - 65
    c = pass_fwd(r[3],o[3],c)
    c = pass_fwd(r[2],o[2],c)
    c = pass_fwd(r[1],o[1],c)
    c = reflector[c+1]
    c = pass_bwd(r[1],o[1],c)
    c = pass_bwd(r[2],o[2],c)
    c = pass_bwd(r[3],o[3],c)
    result ..= string.char(c + 65)
  result

print "Enigma Cipher - MoonScript"
print "Test 1: #{encrypt(0,1,2,0,0,0,'AAAAA')} expected BDZGO"
print "Test 2: #{encrypt(0,1,2,0,0,0,'HELLOWORLD')} expected ILBDAAMTAZ"
