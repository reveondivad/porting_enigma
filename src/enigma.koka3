// Enigma cipher in Bosque (Microsoft Research regularized language)
// Using .koka3 extension to avoid collision
namespace NSEnigma;

function mod26(n: Int): Int {
    let m = n % 26;
    return if(m < 0) m + 26 else m;
}

entity Enigma {
    const rotorFwd1: List<Int> = List<Int>{4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9};
    const rotorFwd2: List<Int> = List<Int>{0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4};
    const rotorFwd3: List<Int> = List<Int>{1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14};
    const reflector: List<Int> = List<Int>{24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19};
    const notches: List<Int> = List<Int>{16, 4, 21};

    method rotorPass(wiring: List<Int>, c: Int, pos: Int): Int {
        return mod26(wiring.get(mod26(c + pos)) - pos);
    }

    method encryptChar(c: Int, p0: Int, p1: Int, p2: Int): Int {
        var x = this.rotorPass(this.rotorFwd3, c, p2);
        x = this.rotorPass(this.rotorFwd2, x, p1);
        x = this.rotorPass(this.rotorFwd1, x, p0);
        x = this.reflector.get(x);
        return x;
    }
}

entrypoint function main(): String {
    return "Enigma Bosque implementation ready";
}
