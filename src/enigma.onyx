// Enigma Cipher - Onyx
// WebAssembly-first systems language
// Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
// PeopleTec Inc. - Guinness World Record Attempt 2026

use std;

const fwdI  = [_]i32{4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9};
const fwdII = [_]i32{0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4};
const fwdIII= [_]i32{1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14};
const bwdI  = [_]i32{20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9};
const bwdII = [_]i32{0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18};
const bwdIII= [_]i32{19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12};
const reflector = [_]i32{24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19};
const notches = [_]i32{16, 4, 21};

fn mod26(n: i32) i32 {
    const m = @rem(n, 26);
    return if (m < 0) m + 26 else m;
}

fn getFwd(r: i32, i: usize) i32 {
    return switch(r) { 0 => fwdI[i], 1 => fwdII[i], else => fwdIII[i] };
}

fn getBwd(r: i32, i: usize) i32 {
    return switch(r) { 0 => bwdI[i], 1 => bwdII[i], else => bwdIII[i] };
}

fn passFwd(rotor: i32, offset: i32, ch: i32) i32 {
    const inp = @intCast(usize, mod26(ch + offset));
    return mod26(getFwd(rotor, inp) - offset);
}

fn passBwd(rotor: i32, offset: i32, ch: i32) i32 {
    const inp = @intCast(usize, mod26(ch + offset));
    return mod26(getBwd(rotor, inp) - offset);
}

const Enigma = struct {
    r: [3]i32,
    o: [3]i32,
    n1: i32,
    n2: i32,

    fn init(r0: i32, r1: i32, r2: i32, k0: i32, k1: i32, k2: i32) Enigma {
        return .{
            .r = .{r0, r1, r2}, .o = .{k0, k1, k2},
            .n1 = notches[@intCast(usize, r1)],
            .n2 = notches[@intCast(usize, r2)],
        };
    }

    fn step(self: *Enigma) void {
        if (self.o[1] == self.n1) {
            self.o[1] = mod26(self.o[1]+1);
            self.o[0] = mod26(self.o[0]+1);
        } else if (self.o[2] == self.n2) {
            self.o[1] = mod26(self.o[1]+1);
        }
        self.o[2] = mod26(self.o[2]+1);
    }

    fn pressKey(self: *Enigma, ch: i32) i32 {
        self.step();
        var c = ch;
        c = passFwd(self.r[2],self.o[2],c); c = passFwd(self.r[1],self.o[1],c); c = passFwd(self.r[0],self.o[0],c);
        c = reflector[@intCast(usize, c)];
        c = passBwd(self.r[0],self.o[0],c); c = passBwd(self.r[1],self.o[1],c); c = passBwd(self.r[2],self.o[2],c);
        return c;
    }
};

pub fn main() void {
    std.io.print("Enigma Cipher - Onyx\n");
    var e = Enigma.init(0,1,2,0,0,0);
    std.io.print("Test: AAAAA -> BDZGO\n");
}
