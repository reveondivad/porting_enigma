; Enigma cipher in Slope (minimal Lisp dialect)
(define rotor-fwd-1 (list 4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9))
(define rotor-fwd-2 (list 0 9 3 10 18 8 17 20 23 1 11 7 22 19 12 2 16 6 25 13 15 24 5 21 14 4))
(define rotor-fwd-3 (list 1 3 5 7 9 11 2 15 17 19 23 21 25 13 24 4 8 22 6 0 10 12 20 18 16 14))
(define rotor-bwd-1 (list 20 22 24 6 0 3 5 15 21 25 1 4 2 10 12 19 7 23 18 11 17 8 13 16 14 9))
(define rotor-bwd-2 (list 0 9 15 2 25 22 17 11 5 1 3 10 14 19 24 20 16 6 4 13 7 23 12 8 21 18))
(define rotor-bwd-3 (list 19 0 6 1 15 2 18 3 16 4 20 5 21 13 25 7 24 8 23 9 22 11 17 10 14 12))
(define reflector (list 24 17 20 7 16 18 11 3 15 23 13 6 14 10 12 8 4 1 5 25 2 22 21 9 0 19))
(define notches (list 16 4 21))

(define (mod26 n) (modulo (+ (modulo n 26) 26) 26))

(define (list-ref lst idx)
  (if (= idx 0) (car lst)
    (list-ref (cdr lst) (- idx 1))))

(define (rotor-pass wiring c pos)
  (mod26 (- (list-ref wiring (mod26 (+ c pos))) pos)))

(define (encrypt-char c p0 p1 p2)
  (let ((c1 (rotor-pass rotor-fwd-3 c p2)))
    (let ((c2 (rotor-pass rotor-fwd-2 c1 p1)))
      (let ((c3 (rotor-pass rotor-fwd-1 c2 p0)))
        (let ((cr (list-ref reflector c3)))
          (let ((c4 (rotor-pass rotor-bwd-1 cr p0)))
            (let ((c5 (rotor-pass rotor-bwd-2 c4 p1)))
              (rotor-pass rotor-bwd-3 c5 p2))))))))

(display "Enigma Slope implementation ready")
(newline)
