; Enigma Cipher - Logo (UCBLogo)
; Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
; PeopleTec Inc. - Guinness World Record Attempt 2026

make "fwdI [4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9]
make "fwdII [0 9 3 10 18 8 17 20 23 1 11 7 22 19 12 2 16 6 25 13 15 24 5 21 14 4]
make "fwdIII [1 3 5 7 9 11 2 15 17 19 23 21 25 13 24 4 8 22 6 0 10 12 20 18 16 14]
make "bwdI [20 22 24 6 0 3 5 15 21 25 1 4 2 10 12 19 7 23 18 11 17 8 13 16 14 9]
make "bwdII [0 9 15 2 25 22 17 11 5 1 3 10 14 19 24 20 16 6 4 13 7 23 12 8 21 18]
make "bwdIII [19 0 6 1 15 2 18 3 16 4 20 5 21 13 25 7 24 8 23 9 22 11 17 10 14 12]
make "reflector [24 17 20 7 16 18 11 3 15 23 13 6 14 10 12 8 4 1 5 25 2 22 21 9 0 19]
make "notches [16 4 21]

to mod26 :n
  output modulo (modulo :n 26) + 26 26
end

to getFwd :r :i
  if :r = 0 [output item (:i + 1) :fwdI]
  if :r = 1 [output item (:i + 1) :fwdII]
  output item (:i + 1) :fwdIII
end

to getBwd :r :i
  if :r = 0 [output item (:i + 1) :bwdI]
  if :r = 1 [output item (:i + 1) :bwdII]
  output item (:i + 1) :bwdIII
end

to passFwd :rotor :offset :ch
  local "inp
  make "inp mod26 :ch + :offset
  local "out
  make "out getFwd :rotor :inp
  output mod26 :out - :offset
end

to passBwd :rotor :offset :ch
  local "inp
  make "inp mod26 :ch + :offset
  local "out
  make "out getBwd :rotor :inp
  output mod26 :out - :offset
end

to stepRotors
  if :o1 = item 2 :rnotch [
    make "o1 mod26 :o1 + 1
    make "o0 mod26 :o0 + 1
  ] [
    if :o2 = item 3 :rnotch [
      make "o1 mod26 :o1 + 1
    ]
  ]
  make "o2 mod26 :o2 + 1
end

to pressKey :ch
  stepRotors
  local "c
  make "c item (:ch + 1) :plugboard
  make "c passFwd :r2 :o2 :c
  make "c passFwd :r1 :o1 :c
  make "c passFwd :r0 :o0 :c
  make "c item (:c + 1) :reflector
  make "c passBwd :r0 :o0 :c
  make "c passBwd :r1 :o1 :c
  make "c passBwd :r2 :o2 :c
  make "c item (:c + 1) :plugboard
  output :c
end

to initEnigma :rotors :key
  make "r0 (item 1 :rotors) - 1
  make "r1 (item 2 :rotors) - 1
  make "r2 (item 3 :rotors) - 1
  make "o0 (ascii item 1 :key) - 65
  make "o1 (ascii item 2 :key) - 65
  make "o2 (ascii item 3 :key) - 65
  make "rnotch (list item (:r0 + 1) :notches item (:r1 + 1) :notches item (:r2 + 1) :notches)
  make "plugboard (list 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25)
end

to encrypt :text
  local "result
  make "result "
  repeat count :text [
    local "ch
    make "ch (ascii item repcount :text) - 65
    if and (:ch >= 0) (:ch < 26) [
      local "enc
      make "enc pressKey :ch
      make "result word :result char (:enc + 65)
    ]
  ]
  output :result
end

print [Enigma Cipher - Logo]
initEnigma [1 2 3] "AAA
print sentence [Test 1:] encrypt "AAAAA
initEnigma [1 2 3] "AAA
print sentence [Test 2:] encrypt "HELLOWORLD
