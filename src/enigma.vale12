// Enigma cipher in Stanza (UC Berkeley systems language)
// Using .vale12 extension to avoid collisions
defpackage enigma :
  import core

val ROTOR-FWD-1 = [4 10 12 5 11 6 3 16 21 25 13 19 14 22 24 7 23 20 18 15 0 8 1 17 2 9]
val ROTOR-FWD-2 = [0 9 3 10 18 8 17 20 23 1 11 7 22 19 12 2 16 6 25 13 15 24 5 21 14 4]
val ROTOR-FWD-3 = [1 3 5 7 9 11 2 15 17 19 23 21 25 13 24 4 8 22 6 0 10 12 20 18 16 14]
val ROTOR-BWD-1 = [20 22 24 6 0 3 5 15 21 25 1 4 2 10 12 19 7 23 18 11 17 8 13 16 14 9]
val ROTOR-BWD-2 = [0 9 15 2 25 22 17 11 5 1 3 10 14 19 24 20 16 6 4 13 7 23 12 8 21 18]
val ROTOR-BWD-3 = [19 0 6 1 15 2 18 3 16 4 20 5 21 13 25 7 24 8 23 9 22 11 17 10 14 12]
val REFLECTOR = [24 17 20 7 16 18 11 3 15 23 13 6 14 10 12 8 4 1 5 25 2 22 21 9 0 19]
val NOTCHES = [16 4 21]

defn mod26 (n:Int) -> Int :
  val m = n % 26
  if m < 0 : m + 26
  else : m

defn rotor-pass (wiring:Tuple<Int>, c:Int, pos:Int) -> Int :
  mod26(wiring[mod26(c + pos)] - pos)

defn enigma (text:String) -> String :
  val pos = Array<Int>(3, 0)
  val buf = StringBuffer()
  for ch in to-upper-case(text) do :
    val c0 = to-int(ch) - 65
    if c0 >= 0 and c0 < 26 :
      val mid = pos[1] == NOTCHES[1]
      if pos[2] == NOTCHES[2] : pos[2] = mod26(pos[2] + 1)
      if mid or pos[2] == NOTCHES[2] : pos[1] = mod26(pos[1] + 1)
      pos[2] = mod26(pos[2] + 1)
      var c = c0
      for i in [2 1 0] do : c = rotor-pass(ROTOR-FWD-1, c, pos[i])
      c = REFLECTOR[c]
      for i in [0 1 2] do : c = rotor-pass(ROTOR-BWD-1, c, pos[i])
      add(buf, to-char(c + 65))
  to-string(buf)

defn main () :
  println(enigma("HELLOWORLD"))
