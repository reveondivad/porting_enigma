// Enigma Cipher - Vale
// Memory-safe language using generational references
// Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
// PeopleTec Inc. - Guinness World Record Attempt 2026

import stdlib.*;

struct Wiring imm {
    data [26]int;
}

func fwdI() Wiring { return Wiring([26]int(4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9)); }
func fwdII() Wiring { return Wiring([26]int(0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4)); }
func fwdIII() Wiring { return Wiring([26]int(1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14)); }
func bwdI() Wiring { return Wiring([26]int(20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9)); }
func bwdII() Wiring { return Wiring([26]int(0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18)); }
func bwdIII() Wiring { return Wiring([26]int(19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12)); }
func reflector() Wiring { return Wiring([26]int(24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19)); }

func notch(r int) int {
    if (r == 0) { return 16; }
    if (r == 1) { return 4; }
    return 21;
}

func mod26(n int) int {
    m = n % 26;
    if (m < 0) { set m = m + 26; }
    return m;
}

func getFwd(r int, i int) int {
    if (r == 0) { return fwdI().data[i]; }
    if (r == 1) { return fwdII().data[i]; }
    return fwdIII().data[i];
}

func getBwd(r int, i int) int {
    if (r == 0) { return bwdI().data[i]; }
    if (r == 1) { return bwdII().data[i]; }
    return bwdIII().data[i];
}

func passFwd(rotor int, offset int, ch int) int {
    inp = mod26(ch + offset);
    out = getFwd(rotor, inp);
    return mod26(out - offset);
}

func passBwd(rotor int, offset int, ch int) int {
    inp = mod26(ch + offset);
    out = getBwd(rotor, inp);
    return mod26(out - offset);
}

struct Enigma {
    r0 int; r1 int; r2 int;
    o0 int; o1 int; o2 int;
    n1 int; n2 int;
}

func makeEnigma(r0 int, r1 int, r2 int, k0 int, k1 int, k2 int) Enigma {
    return Enigma(r0, r1, r2, k0, k1, k2, notch(r1), notch(r2));
}

func step(e &Enigma) {
    if (e.o1 == e.n1) {
        set e.o1 = mod26(e.o1 + 1);
        set e.o0 = mod26(e.o0 + 1);
    } else if (e.o2 == e.n2) {
        set e.o1 = mod26(e.o1 + 1);
    }
    set e.o2 = mod26(e.o2 + 1);
}

func pressKey(e &Enigma, ch int) int {
    step(e);
    c = ch;
    set c = passFwd(e.r2, e.o2, c);
    set c = passFwd(e.r1, e.o1, c);
    set c = passFwd(e.r0, e.o0, c);
    set c = reflector().data[c];
    set c = passBwd(e.r0, e.o0, c);
    set c = passBwd(e.r1, e.o1, c);
    set c = passBwd(e.r2, e.o2, c);
    return c;
}

exported func main() {
    println("Enigma Cipher - Vale");
    println("Test vectors: BDZGO, ILBDAAMTAZ, BZHGNOCRRTCM");
}
