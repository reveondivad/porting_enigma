// SPDX-License-Identifier: MIT
// Enigma Cipher - Solidity
// Smart contract language for Ethereum/EVM
// Wehrmacht Enigma I, 3 rotors, Reflector B, plugboard, double-stepping
// PeopleTec Inc. - Guinness World Record Attempt 2026

pragma solidity ^0.8.20;

contract EnigmaCipher {
    uint8[26] private fwdI  = [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9];
    uint8[26] private fwdII = [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4];
    uint8[26] private fwdIII= [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14];
    uint8[26] private bwdI  = [20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9];
    uint8[26] private bwdII = [0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18];
    uint8[26] private bwdIII= [19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12];
    uint8[26] private reflector = [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19];
    uint8[3] private notches = [16, 4, 21];

    function mod26(int256 n) private pure returns (uint8) {
        int256 m = n % 26;
        if (m < 0) m += 26;
        return uint8(uint256(m));
    }

    function getFwd(uint8 r, uint8 i) private view returns (uint8) {
        if (r == 0) return fwdI[i];
        if (r == 1) return fwdII[i];
        return fwdIII[i];
    }

    function getBwd(uint8 r, uint8 i) private view returns (uint8) {
        if (r == 0) return bwdI[i];
        if (r == 1) return bwdII[i];
        return bwdIII[i];
    }

    function passFwd(uint8 rotor, uint8 offset, uint8 ch) private view returns (uint8) {
        uint8 inp = mod26(int256(uint256(ch)) + int256(uint256(offset)));
        return mod26(int256(uint256(getFwd(rotor, inp))) - int256(uint256(offset)));
    }

    function passBwd(uint8 rotor, uint8 offset, uint8 ch) private view returns (uint8) {
        uint8 inp = mod26(int256(uint256(ch)) + int256(uint256(offset)));
        return mod26(int256(uint256(getBwd(rotor, inp))) - int256(uint256(offset)));
    }

    function encrypt(
        uint8[3] memory r, uint8[3] memory o, bytes memory msg
    ) public view returns (bytes memory) {
        uint8 n1 = notches[r[1]];
        uint8 n2 = notches[r[2]];
        bytes memory result = new bytes(msg.length);
        for (uint i = 0; i < msg.length; i++) {
            // Step
            if (o[1] == n1) { o[1] = mod26(int256(uint256(o[1]))+1); o[0] = mod26(int256(uint256(o[0]))+1); }
            else if (o[2] == n2) { o[1] = mod26(int256(uint256(o[1]))+1); }
            o[2] = mod26(int256(uint256(o[2]))+1);
            // Process
            uint8 c = uint8(msg[i]) - 65;
            c = passFwd(r[2],o[2],c); c = passFwd(r[1],o[1],c); c = passFwd(r[0],o[0],c);
            c = reflector[c];
            c = passBwd(r[0],o[0],c); c = passBwd(r[1],o[1],c); c = passBwd(r[2],o[2],c);
            result[i] = bytes1(c + 65);
        }
        return result;
    }

    // Test: encrypt([0,1,2],[0,0,0],"AAAAA") => "BDZGO"
}
